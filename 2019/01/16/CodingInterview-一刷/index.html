<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="oj,面试,">










<meta name="description" content="1. 找出数组中重复的数字题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或者3。  排序后遍历 利用hash表，遍历数组，判断当前数字是否是在hash表中，没有，加入。有，则">
<meta name="keywords" content="oj,面试">
<meta property="og:type" content="article">
<meta property="og:title" content="CodingInterview 一刷">
<meta property="og:url" content="http://yoursite.com/2019/01/16/CodingInterview-一刷/index.html">
<meta property="og:site_name" content="七月的风">
<meta property="og:description" content="1. 找出数组中重复的数字题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或者3。  排序后遍历 利用hash表，遍历数组，判断当前数字是否是在hash表中，没有，加入。有，则">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-01-16T12:39:54.609Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CodingInterview 一刷">
<meta name="twitter:description" content="1. 找出数组中重复的数字题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或者3。  排序后遍历 利用hash表，遍历数组，判断当前数字是否是在hash表中，没有，加入。有，则">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/01/16/CodingInterview-一刷/">





  <title>CodingInterview 一刷 | 七月的风</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">七月的风</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/16/CodingInterview-一刷/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Poemlin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/xw.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="七月的风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">CodingInterview 一刷</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-16T20:04:10+08:00">
                2019-01-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="1-找出数组中重复的数字"><a href="#1-找出数组中重复的数字" class="headerlink" title="1. 找出数组中重复的数字"></a>1. 找出数组中重复的数字</h3><p>题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或者3。</p>
<ol>
<li>排序后遍历</li>
<li>利用hash表，遍历数组，判断当前数字是否是在hash表中，没有，加入。有，则是重复数字。</li>
<li>n长的数组，数字范围0-n-1，则排好序的话，i位置上存放i值才是没有重复的。遍历数组，扫描到i位置，如果arr[i]==i,则扫描下一个位置，否则和第m=arr[i]的位置比较，如果相等，找到重复。如果不相等，交换两者。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bool duplicate(int numbers[], int length, int* duplication)</span><br><span class="line">&#123;</span><br><span class="line">    if(numbers == nullptr || length &lt;= 0)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(numbers[i] &lt; 0 || numbers[i] &gt; length - 1)</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        while(numbers[i] != i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(numbers[i] == numbers[numbers[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 交换numbers[i]和numbers[numbers[i]]             </span><br><span class="line">            int temp = numbers[i];</span><br><span class="line">            numbers[i] = numbers[temp];</span><br><span class="line">            numbers[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-不修改数组找出重复的数字"><a href="#2-不修改数组找出重复的数字" class="headerlink" title="2. 不修改数组找出重复的数字"></a>2. 不修改数组找出重复的数字</h3><p>题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或者3。不能修改数组</p>
<p>数字范围是0-n-1，我们试着不在原数组里找重复元素，而是思考0-n-1内到底哪个重复了。二分0-n-1；0-m，m-n-1；如果前者在原数组中出现次数超过了m，则0-m内一定有重复出现的。之后在0-m内再二分。二分的思想。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int getDuplication(const int* numbers, int length)</span><br><span class="line">&#123;</span><br><span class="line">    if(numbers == nullptr || length &lt;= 0)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    int start = 1;</span><br><span class="line">    int end = length - 1;</span><br><span class="line">    while(end &gt;= start)</span><br><span class="line">    &#123;</span><br><span class="line">        int middle = ((end - start) &gt;&gt; 1) + start;</span><br><span class="line">        int count = countRange(numbers, length, start, middle);</span><br><span class="line">        if(end == start)</span><br><span class="line">        &#123;</span><br><span class="line">            if(count &gt; 1)</span><br><span class="line">                return start;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(count &gt; (middle - start + 1))</span><br><span class="line">            end = middle;</span><br><span class="line">        else</span><br><span class="line">            start = middle + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int countRange(const int* numbers, int length, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">    if(numbers == nullptr)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int count = 0;</span><br><span class="line">    for(int i = 0; i &lt; length; i++)</span><br><span class="line">        if(numbers[i] &gt;= start &amp;&amp; numbers[i] &lt;= end)</span><br><span class="line">            ++count;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-有序二维数组中找是否存在某个整数"><a href="#3-有序二维数组中找是否存在某个整数" class="headerlink" title="3. 有序二维数组中找是否存在某个整数"></a>3. 有序二维数组中找是否存在某个整数</h3><p>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>从右上角那个数字开始，如果是，返回true。如果大于，则这一列不考虑，向左移动。如果小于，则整行不考虑，向下移动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bool Find(int* matrix, int rows, int columns, int number)</span><br><span class="line">&#123;</span><br><span class="line">    bool found = false;</span><br><span class="line"></span><br><span class="line">    if(matrix != nullptr &amp;&amp; rows &gt; 0 &amp;&amp; columns &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        int row = 0;</span><br><span class="line">        int column = columns - 1;</span><br><span class="line">        while(row &lt; rows &amp;&amp; column &gt;=0)</span><br><span class="line">        &#123;</span><br><span class="line">            if(matrix[row * columns + column] == number)</span><br><span class="line">            &#123;</span><br><span class="line">                found = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(matrix[row * columns + column] &gt; number)</span><br><span class="line">                -- column;</span><br><span class="line">            else</span><br><span class="line">                ++ row;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-替换空格"><a href="#4-替换空格" class="headerlink" title="4 替换空格"></a>4 替换空格</h3><p>题目：请实现一个函数，把字符串中的每个空格替换成”%20”。例如输入“We are happy.”，则输出“We%20are%20happy.”。</p>
<p>从开头遍历的话，会重复移动字符。首先遍历字符串，找到一共有几个空格，则新的字符大小就是n+2*m, 从末尾开始遍历数组。两个指针，i指向原始数组末尾，j指向新字符串末尾（已知大小）。i，j同时向前移动，j复制i，直到遇到空格，i向前，j插入%20。如果i和j指向同一个位置，则所有空格填充完毕。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">void ReplaceBlank(char str[], int length)</span><br><span class="line">&#123;</span><br><span class="line">    if(str == nullptr &amp;&amp; length &lt;= 0)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    /*originalLength 为字符串str的实际长度*/</span><br><span class="line">    int originalLength = 0;</span><br><span class="line">    int numberOfBlank = 0;</span><br><span class="line">    int i = 0;</span><br><span class="line">    while(str[i] != &apos;\0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        ++ originalLength;</span><br><span class="line"></span><br><span class="line">        if(str[i] == &apos; &apos;)</span><br><span class="line">            ++ numberOfBlank;</span><br><span class="line"></span><br><span class="line">        ++ i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*newLength 为把空格替换成&apos;%20&apos;之后的长度*/</span><br><span class="line">    int newLength = originalLength + numberOfBlank * 2;</span><br><span class="line">    if(newLength &gt; length)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    int indexOfOriginal = originalLength;</span><br><span class="line">    int indexOfNew = newLength;</span><br><span class="line">    while(indexOfOriginal &gt;= 0 &amp;&amp; indexOfNew &gt; indexOfOriginal)</span><br><span class="line">    &#123;</span><br><span class="line">        if(str[indexOfOriginal] == &apos; &apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            str[indexOfNew --] = &apos;0&apos;;</span><br><span class="line">            str[indexOfNew --] = &apos;2&apos;;</span><br><span class="line">            str[indexOfNew --] = &apos;%&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            str[indexOfNew --] = str[indexOfOriginal];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        -- indexOfOriginal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-从尾到头打印链表"><a href="#5-从尾到头打印链表" class="headerlink" title="5. 从尾到头打印链表"></a>5. 从尾到头打印链表</h3><p>题目：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。</p>
<p>很自然可以想到使用栈，从头开始遍历，遍历到一个节点，先不要输出，先把value压栈。最后遍历完，依次出栈。</p>
<p>可以使用栈的方法都可以使用递归，当我们遍历到一个节点时，先递归输出它前面的节点，再输出自己的节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void PrintListReversingly_Iteratively(ListNode* pHead)</span><br><span class="line">&#123;</span><br><span class="line">    std::stack&lt;ListNode*&gt; nodes;</span><br><span class="line"></span><br><span class="line">    ListNode* pNode = pHead;</span><br><span class="line">    while(pNode != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        nodes.push(pNode);</span><br><span class="line">        pNode = pNode-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(!nodes.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        pNode = nodes.top();</span><br><span class="line">        printf(&quot;%d\t&quot;, pNode-&gt;m_nValue);</span><br><span class="line">        nodes.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PrintListReversingly_Recursively(ListNode* pHead)</span><br><span class="line">&#123;</span><br><span class="line">    if(pHead != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        if (pHead-&gt;m_pNext != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            PrintListReversingly_Recursively(pHead-&gt;m_pNext);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        printf(&quot;%d\t&quot;, pHead-&gt;m_nValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-先序中序重建二叉树"><a href="#6-先序中序重建二叉树" class="headerlink" title="6.先序中序重建二叉树"></a>6.先序中序重建二叉树</h3><p>题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}，</p>
<p>先序遍历第一个值就是根节点，根据这个值可以在中序中划分左右子树，我们这里已经将一个数划分成两颗子树，那么在递归的使用刚刚的分析可以继续分开，直到叶子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">BinaryTreeNode* ConstructCore(int* startPreorder, int* endPreorder, int* startInorder, int* endInorder);</span><br><span class="line"></span><br><span class="line">BinaryTreeNode* Construct(int* preorder, int* inorder, int length)</span><br><span class="line">&#123;</span><br><span class="line">    if(preorder == nullptr || inorder == nullptr || length &lt;= 0)</span><br><span class="line">        return nullptr;</span><br><span class="line"></span><br><span class="line">    return ConstructCore(preorder, preorder + length - 1,</span><br><span class="line">        inorder, inorder + length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinaryTreeNode* ConstructCore</span><br><span class="line">(</span><br><span class="line">    int* startPreorder, int* endPreorder, </span><br><span class="line">    int* startInorder, int* endInorder</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    // 前序遍历序列的第一个数字是根结点的值</span><br><span class="line">    int rootValue = startPreorder[0];</span><br><span class="line">    BinaryTreeNode* root = new BinaryTreeNode();</span><br><span class="line">    root-&gt;m_nValue = rootValue;</span><br><span class="line">    root-&gt;m_pLeft = root-&gt;m_pRight = nullptr;</span><br><span class="line"></span><br><span class="line">    if(startPreorder == endPreorder)</span><br><span class="line">    &#123;</span><br><span class="line">        if(startInorder == endInorder &amp;&amp; *startPreorder == *startInorder)</span><br><span class="line">            return root;</span><br><span class="line">        else</span><br><span class="line">            throw std::exception(&quot;Invalid input.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在中序遍历中找到根结点的值</span><br><span class="line">    int* rootInorder = startInorder;</span><br><span class="line">    while(rootInorder &lt;= endInorder &amp;&amp; *rootInorder != rootValue)</span><br><span class="line">        ++ rootInorder;</span><br><span class="line"></span><br><span class="line">    if(rootInorder == endInorder &amp;&amp; *rootInorder != rootValue)</span><br><span class="line">        throw std::exception(&quot;Invalid input.&quot;);</span><br><span class="line"></span><br><span class="line">    int leftLength = rootInorder - startInorder;</span><br><span class="line">    int* leftPreorderEnd = startPreorder + leftLength;</span><br><span class="line">    if(leftLength &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        // 构建左子树</span><br><span class="line">        root-&gt;m_pLeft = ConstructCore(startPreorder + 1, leftPreorderEnd, </span><br><span class="line">            startInorder, rootInorder - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    if(leftLength &lt; endPreorder - startPreorder)</span><br><span class="line">    &#123;</span><br><span class="line">        // 构建右子树</span><br><span class="line">        root-&gt;m_pRight = ConstructCore(leftPreorderEnd + 1, endPreorder,</span><br><span class="line">            rootInorder + 1, endInorder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-二叉树的下一个结点"><a href="#7-二叉树的下一个结点" class="headerlink" title="7.二叉树的下一个结点"></a>7.二叉树的下一个结点</h3><p>给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，还有一个指向父结点的指针。</p>
<p>分三种情况</p>
<p>如果当前节点有右子树，则下一个节点是右子树的最左边的节点。</p>
<p>如果当前节点没有右子树，并且它是它父节点的左孩子，那么下一个节点就是它的父节点。</p>
<p>如果当前节点没有右子树，并且它是它父节点的右孩子，那么一直向上找父节点，直到找到一个节点是其父节点的左孩子，则这个父节点就是下一个孩子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">struct BinaryTreeNode</span><br><span class="line">&#123;</span><br><span class="line">    int                    m_nValue;</span><br><span class="line">    BinaryTreeNode*        m_pLeft;</span><br><span class="line">    BinaryTreeNode*        m_pRight;</span><br><span class="line">    BinaryTreeNode*        m_pParent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BinaryTreeNode* GetNext(BinaryTreeNode* pNode)</span><br><span class="line">&#123;</span><br><span class="line">    if(pNode == nullptr)</span><br><span class="line">        return nullptr;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode* pNext = nullptr;</span><br><span class="line">    if(pNode-&gt;m_pRight != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* pRight = pNode-&gt;m_pRight;</span><br><span class="line">        while(pRight-&gt;m_pLeft != nullptr)</span><br><span class="line">            pRight = pRight-&gt;m_pLeft;</span><br><span class="line"></span><br><span class="line">        pNext = pRight;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pNode-&gt;m_pParent != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* pCurrent = pNode;</span><br><span class="line">        BinaryTreeNode* pParent = pNode-&gt;m_pParent;</span><br><span class="line">        while(pParent != nullptr &amp;&amp; pCurrent == pParent-&gt;m_pRight)</span><br><span class="line">        &#123;</span><br><span class="line">            pCurrent = pParent;</span><br><span class="line">            pParent = pParent-&gt;m_pParent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pNext = pParent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="8-用栈实现队列。"><a href="#8-用栈实现队列。" class="headerlink" title="8.用栈实现队列。"></a>8.用栈实现队列。</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail和deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能。</p>
<p>使用两个栈，一个push栈，和一个pop栈。用于实现队列的push和pop操作，队列push时，只要将数据压入push栈，pop时，把push栈里的东西一次压入pop再弹出。但是要注意两个注意点，如果push栈里有东西，一定不能从pop栈理出，要先到push栈。同时，push栈必须一次全部倒完。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; void CQueue&lt;T&gt;::appendTail(const T&amp; element)</span><br><span class="line">&#123;</span><br><span class="line">    stack1.push(element);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt; T CQueue&lt;T&gt;::deleteHead()</span><br><span class="line">&#123;</span><br><span class="line">    if(stack2.size()&lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        while(stack1.size()&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            T&amp; data = stack1.top();</span><br><span class="line">            stack1.pop();</span><br><span class="line">            stack2.push(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(stack2.size() == 0)</span><br><span class="line">        throw new exception(&quot;queue is empty&quot;);</span><br><span class="line"></span><br><span class="line">    T head = stack2.top();</span><br><span class="line">    stack2.pop();</span><br><span class="line"></span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-斐波那契数列"><a href="#9-斐波那契数列" class="headerlink" title="9.斐波那契数列"></a>9.斐波那契数列</h3><p>题目：写一个函数，输入n，求斐波那契（Fibonacci）数列的第n项。</p>
<p>递归的方法很好写，但是递归的方法效率极低，会有很多重复计算，尤其是n很大的时候。</p>
<p>使用迭代的方法，记录前面计算的值。</p>
<p>通项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">long long Fibonacci_Solution1(unsigned int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(n &lt;= 0)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    if(n == 1)</span><br><span class="line">        return 1;</span><br><span class="line"></span><br><span class="line">    return Fibonacci_Solution1(n - 1) + Fibonacci_Solution1(n - 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long Fibonacci_Solution2(unsigned n)</span><br><span class="line">&#123;</span><br><span class="line">    int result[2] = &#123;0, 1&#125;;</span><br><span class="line">    if(n &lt; 2)</span><br><span class="line">        return result[n];</span><br><span class="line"></span><br><span class="line">    long long  fibNMinusOne = 1;</span><br><span class="line">    long long  fibNMinusTwo = 0;</span><br><span class="line">    long long  fibN = 0;</span><br><span class="line">    for(unsigned int i = 2; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        fibN = fibNMinusOne + fibNMinusTwo;</span><br><span class="line"></span><br><span class="line">        fibNMinusTwo = fibNMinusOne;</span><br><span class="line">        fibNMinusOne = fibN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     return fibN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-在旋转数组中查找某个数字"><a href="#10-在旋转数组中查找某个数字" class="headerlink" title="10.在旋转数组中查找某个数字"></a>10.在旋转数组中查找某个数字</h3><p>谈到查找，立刻想到顺序查找，二分查找，hash查找，搜索二叉树。顺序查找O(N),二分查找O(logN)，hash O(1)但是以空间为代价。</p>
<p>这题可以使用二分法，先将数组二分，那么两边必定有一边是顺序的，那么在顺序一边查找，如果找到，则返回。如果找不到，则在另一边继续二分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        // 线性表搜索问题一般都会用到二分法</span><br><span class="line">        // 二分法涉及三个指针min max mid</span><br><span class="line">        int min = 0, max = nums.size()-1, mid = 0;</span><br><span class="line">        // 二分法最终的停止条件</span><br><span class="line">        while(min &lt;= max)&#123;</span><br><span class="line">            // 初始第一次二分的mid</span><br><span class="line">             int mid = (min+max)/2;</span><br><span class="line">             // 如果mid恰好是target(最终target都会到mid这里)</span><br><span class="line">             if(nums[mid] == target)    return mid;</span><br><span class="line">             // 如果左半部分有序,则在此半部分（有序字符串）进行二分查找</span><br><span class="line">             if(nums[min] &lt;= nums[mid])&#123;</span><br><span class="line">                 if(nums[min]&lt;=target &amp;&amp; target&lt;nums[mid])</span><br><span class="line">                    max = mid - 1;</span><br><span class="line">                else</span><br><span class="line">                    min = mid + 1;</span><br><span class="line">             &#125;</span><br><span class="line">             // 如果右半部分有序</span><br><span class="line">             else&#123;</span><br><span class="line">                 if(nums[mid]&lt; target &amp;&amp; target&lt;=nums[max])</span><br><span class="line">                    min = mid + 1;</span><br><span class="line">                else</span><br><span class="line">                    max = mid - 1;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 不满足最高二分条件min&lt;=max时</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="11-矩阵中的路径"><a href="#11-矩阵中的路径" class="headerlink" title="11.矩阵中的路径"></a>11.矩阵中的路径</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进该格子。例如在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用下划线标出）。但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<p>回溯加递归：初始index为0，然后随机选取矩阵上一点，判断该点是否是str(index),是的话，index+1.判断其它四个方向的点是否是str(index+1),只要有一个是，则继续。如果不是，则返回上一个点。注意需要一个和矩阵大小一样的表来帮助记录哪些点已经访问过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool hasPathCore(const char* matrix, int rows, int cols, int row, int col, const char* str, int&amp; pathLength, bool* visited);</span><br><span class="line"></span><br><span class="line">bool hasPath(const char* matrix, int rows, int cols, const char* str)</span><br><span class="line">&#123;</span><br><span class="line">    if(matrix == nullptr || rows &lt; 1 || cols &lt; 1 || str == nullptr)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    bool *visited = new bool[rows * cols];</span><br><span class="line">    memset(visited, 0, rows * cols);</span><br><span class="line"></span><br><span class="line">    int pathLength = 0;</span><br><span class="line">    for(int row = 0; row &lt; rows; ++row)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int col = 0; col &lt; cols; ++col)</span><br><span class="line">        &#123;</span><br><span class="line">            if(hasPathCore(matrix, rows, cols, row, col, str,</span><br><span class="line">                pathLength, visited))</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete[] visited;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool hasPathCore(const char* matrix, int rows, int cols, int row,</span><br><span class="line">    int col, const char* str, int&amp; pathLength, bool* visited)</span><br><span class="line">&#123;</span><br><span class="line">    if(str[pathLength] == &apos;\0&apos;)</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    bool hasPath = false;</span><br><span class="line">    if(row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols</span><br><span class="line">        &amp;&amp; matrix[row * cols + col] == str[pathLength]</span><br><span class="line">        &amp;&amp; !visited[row * cols + col])</span><br><span class="line">    &#123;</span><br><span class="line">        ++pathLength;</span><br><span class="line">        visited[row * cols + col] = true;</span><br><span class="line"></span><br><span class="line">        hasPath = hasPathCore(matrix, rows, cols, row, col - 1,</span><br><span class="line">            str, pathLength, visited)</span><br><span class="line">            || hasPathCore(matrix, rows, cols, row - 1, col,</span><br><span class="line">                str, pathLength, visited)</span><br><span class="line">            || hasPathCore(matrix, rows, cols, row, col + 1,</span><br><span class="line">                str, pathLength, visited)</span><br><span class="line">            || hasPathCore(matrix, rows, cols, row + 1, col,</span><br><span class="line">                str, pathLength, visited);</span><br><span class="line"></span><br><span class="line">        if(!hasPath)</span><br><span class="line">        &#123;</span><br><span class="line">            --pathLength;</span><br><span class="line">            visited[row * cols + col] = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return hasPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-机器人的运动范围"><a href="#12-机器人的运动范围" class="headerlink" title="12.机器人的运动范围"></a>12.机器人的运动范围</h3><p>地上有一个m行n列的方格。一个机器人从坐标(0, 0)的格子开始移动，它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格(35, 37)，因为3+5+3+7=18。<br>但它不能进入方格(35, 38)，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p>一般在矩阵中走路的题目都是i回溯法+递归。判断最大行走路径，先判断一个点是否是可以行走的，是的，则路径=1+其它四个路径的点最大路径的和。注意也要用一个数组记录每一个点是否已经访问过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// 很有意思</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">int movingCountCore(int threshold, int rows, int cols, int row, int col, bool* visited);</span><br><span class="line">bool check(int threshold, int rows, int cols, int row, int col, bool* visited);</span><br><span class="line">int getDigitSum(int number);</span><br><span class="line"></span><br><span class="line">// 主函数</span><br><span class="line">int movingCount(int threshold, int rows, int cols)</span><br><span class="line">&#123;</span><br><span class="line">    if(threshold &lt; 0 || rows &lt;= 0 || cols &lt;= 0)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    bool *visited = new bool[rows * cols];</span><br><span class="line">    for(int i = 0; i &lt; rows * cols; ++i)</span><br><span class="line">        visited[i] = false;</span><br><span class="line"></span><br><span class="line">    int count = movingCountCore(threshold, rows, cols,</span><br><span class="line">        0, 0, visited);</span><br><span class="line"></span><br><span class="line">    delete[] visited;</span><br><span class="line"></span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 计算矩阵最长行走路径</span><br><span class="line">int movingCountCore(int threshold, int rows, int cols, int row,</span><br><span class="line">    int col, bool* visited)</span><br><span class="line">&#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    if(check(threshold, rows, cols, row, col, visited))</span><br><span class="line">    &#123;</span><br><span class="line">        visited[row * cols + col] = true;</span><br><span class="line"></span><br><span class="line">        count = 1 + movingCountCore(threshold, rows, cols,</span><br><span class="line">            row - 1, col, visited)</span><br><span class="line">            + movingCountCore(threshold, rows, cols,</span><br><span class="line">                row, col - 1, visited)</span><br><span class="line">            + movingCountCore(threshold, rows, cols,</span><br><span class="line">                row + 1, col, visited)</span><br><span class="line">            + movingCountCore(threshold, rows, cols,</span><br><span class="line">                row, col + 1, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检查当前点是否可以进入</span><br><span class="line">bool check(int threshold, int rows, int cols, int row, int col,</span><br><span class="line">    bool* visited)</span><br><span class="line">&#123;</span><br><span class="line">    if(row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols</span><br><span class="line">        &amp;&amp; getDigitSum(row) + getDigitSum(col) &lt;= threshold</span><br><span class="line">        &amp;&amp; !visited[row* cols + col])</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检查当前点数为之和</span><br><span class="line">int getDigitSum(int number)</span><br><span class="line">&#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    while(number &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += number % 10;</span><br><span class="line">        number /= 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-剪绳子"><a href="#13-剪绳子" class="headerlink" title="13.剪绳子"></a>13.剪绳子</h3><p>题目：给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]<em>k[1]</em>…*k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。</p>
<p>动态规划的思想，长度为n的剪为两半最大乘积，可以分解为两半各自剪断的最大值。所以可以不断分解成子问题，直到最小的子问题。但是从上到下的方式会计算重复子问题。所以可以从自问题出发，计算最小子问题解，次最下，。。。后面的子问题都是依赖前面的。所以可以不断根据前面计算的子问题解计算后面的问题。这些从第向上的子问题的解都存放在一个数组里。</p>
<p>贪婪的思想，当n&gt;5时，尽可能剪断3，n=4时，剪2.贪婪的算法都是可以用数学求解的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">// ====================动态规划====================</span><br><span class="line">int maxProductAfterCutting_solution1(int length)</span><br><span class="line">&#123;</span><br><span class="line">    if(length &lt; 2)</span><br><span class="line">        return 0;</span><br><span class="line">    if(length == 2)</span><br><span class="line">        return 1;</span><br><span class="line">    if(length == 3)</span><br><span class="line">        return 2;</span><br><span class="line"></span><br><span class="line">    int* products = new int[length + 1];</span><br><span class="line">    products[0] = 0;</span><br><span class="line">    products[1] = 1;</span><br><span class="line">    products[2] = 2;</span><br><span class="line">    products[3] = 3;</span><br><span class="line"></span><br><span class="line">    int max = 0;</span><br><span class="line">    for(int i = 4; i &lt;= length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        max = 0;</span><br><span class="line">        for(int j = 1; j &lt;= i / 2; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            int product = products[j] * products[i - j];</span><br><span class="line">            if(max &lt; product)</span><br><span class="line">                max = product;</span><br><span class="line"></span><br><span class="line">            products[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    max = products[length];</span><br><span class="line">    delete[] products;</span><br><span class="line"></span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ====================贪婪算法====================</span><br><span class="line">int maxProductAfterCutting_solution2(int length)</span><br><span class="line">&#123;</span><br><span class="line">    if(length &lt; 2)</span><br><span class="line">        return 0;</span><br><span class="line">    if(length == 2)</span><br><span class="line">        return 1;</span><br><span class="line">    if(length == 3)</span><br><span class="line">        return 2;</span><br><span class="line"></span><br><span class="line">    // 尽可能多地减去长度为3的绳子段</span><br><span class="line">    int timesOf3 = length / 3;</span><br><span class="line"></span><br><span class="line">    // 当绳子最后剩下的长度为4的时候，不能再剪去长度为3的绳子段。</span><br><span class="line">    // 此时更好的方法是把绳子剪成长度为2的两段，因为2*2 &gt; 3*1。</span><br><span class="line">    if(length - timesOf3 * 3 == 1)</span><br><span class="line">        timesOf3 -= 1;</span><br><span class="line"></span><br><span class="line">    int timesOf2 = (length - timesOf3 * 3) / 2;</span><br><span class="line"></span><br><span class="line">    return (int) (pow(3, timesOf3)) * (int) (pow(2, timesOf2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-二进制中1的个数"><a href="#14-二进制中1的个数" class="headerlink" title="14.二进制中1的个数"></a>14.二进制中1的个数</h3><p>题目：请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。</p>
<p>这题可以理解为二进制的位运算，求一个数中1的个数，可以将这个数与1与，如果是1，则末尾为1，num++，然后1左移一位，再和这个数与，判断第二位是否为1.</p>
<p>注意是1左移，而不是数右移，是因为右移需要考虑有符号数的情况。</p>
<p>上面的解法需要遍历每一个位置，有一个方法可以有几个1就进行几次。基于这样的想法：把一个整数减去1，再和原来的整数与，就可以把最右边的1变成0。</p>
<p>上面的想法还可以用于这样的题目：判断一个数是不是2的整数次方，因为满足的情况，所有为只有一位是1，其它都是0.那么经过上面的一次计算即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">int NumberOf1_Solution1(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    unsigned int flag = 1;</span><br><span class="line">    while (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        if (n &amp; flag)</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">        flag = flag &lt;&lt; 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int NumberOf1_Solution2(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    while (n)</span><br><span class="line">    &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        n = (n - 1) &amp; n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-数值的k次方"><a href="#15-数值的k次方" class="headerlink" title="15.数值的k次方"></a>15.数值的k次方</h3><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<p>需要思考：指数如果是负数，指数如果是负数，可以先对指数取绝对值，算出k次方，再取倒数。取到数时也要注意，底数为0时的情况。</p>
<p>递归的思想，n求k次方，如果k是偶数，则求n的k/2次方再平方即可。如果k是奇数，求n的k-1/2的平方再乘n即可。这类似与费波纳且</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">bool g_InvalidInput = false;</span><br><span class="line">bool equal(double num1, double num2);</span><br><span class="line">double PowerWithUnsignedExponent(double base, unsigned int exponent);</span><br><span class="line"></span><br><span class="line">double Power(double base, int exponent)</span><br><span class="line">&#123;</span><br><span class="line">    g_InvalidInput = false;</span><br><span class="line"></span><br><span class="line">    if (equal(base, 0.0) &amp;&amp; exponent &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        g_InvalidInput = true;</span><br><span class="line">        return 0.0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unsigned int absExponent = (unsigned int) (exponent);</span><br><span class="line">    if (exponent &lt; 0)</span><br><span class="line">        absExponent = (unsigned int) (-exponent);</span><br><span class="line"></span><br><span class="line">    double result = PowerWithUnsignedExponent(base, absExponent);</span><br><span class="line">    if (exponent &lt; 0)</span><br><span class="line">        result = 1.0 / result;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double PowerWithUnsignedExponent(double base, unsigned int exponent)</span><br><span class="line">&#123;</span><br><span class="line">    if (exponent == 0)</span><br><span class="line">        return 1;</span><br><span class="line">    if (exponent == 1)</span><br><span class="line">        return base;</span><br><span class="line">    // 使用右移代替除2</span><br><span class="line">    double result = PowerWithUnsignedExponent(base, exponent &gt;&gt; 1);</span><br><span class="line">    result *= result;</span><br><span class="line">    // 使用与运算判断奇偶</span><br><span class="line">    if ((exponent &amp; 0x1) == 1)</span><br><span class="line">        result *= base;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断两个小数是否相等不能使用==</span><br><span class="line">bool equal(double num1, double num2)</span><br><span class="line">&#123;</span><br><span class="line">    if ((num1 - num2 &gt; -0.0000001) &amp;&amp; (num1 - num2 &lt; 0.0000001))</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16-打印1到最大的n位数"><a href="#16-打印1到最大的n位数" class="headerlink" title="16.打印1到最大的n位数"></a>16.打印1到最大的n位数</h3><p>题目：输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。</p>
<p>如果用int或long存储数字，那么n稍微大一点就会越界。对于大数问题，我们使用字符串表示数字。对于一个n位的整数，我们可以有n+1位的字符串表示。同时，n位的所有十进制数其实就是n个从0到9的全排列。</p>
<p>全排列可以使用递归，数字的每一位都可能是0-9的一个数，然后设置下一个数，递归结束的条件就是我们设置了而最后一位数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">void Print1ToMaxOfNDigits_2(int n)</span><br><span class="line">&#123;</span><br><span class="line">    if (n &lt;= 0)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    char* number = new char[n + 1];</span><br><span class="line">    number[n] = &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 10; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        number[0] = i + &apos;0&apos;;</span><br><span class="line">        Print1ToMaxOfNDigitsRecursively(number, n, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete[] number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Print1ToMaxOfNDigitsRecursively(char* number, int length, int index)</span><br><span class="line">&#123;</span><br><span class="line">    if (index == length - 1)</span><br><span class="line">    &#123;</span><br><span class="line">        PrintNumber(number);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 10; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        number[index + 1] = i + &apos;0&apos;;</span><br><span class="line">        Print1ToMaxOfNDigitsRecursively(number, length, index + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PrintNumber(char* number)</span><br><span class="line">&#123;</span><br><span class="line">    bool isBeginning0 = true;</span><br><span class="line">    int nLength = strlen(number);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; nLength; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (isBeginning0 &amp;&amp; number[i] != &apos;0&apos;)</span><br><span class="line">            isBeginning0 = false;</span><br><span class="line"></span><br><span class="line">        if (!isBeginning0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%c&quot;, number[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\t&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-在O-1-时间删除链表结点"><a href="#17-在O-1-时间删除链表结点" class="headerlink" title="17 在O(1)时间删除链表结点"></a>17 在O(1)时间删除链表结点</h3><p>题目：给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。</p>
<p>一般得删除方法，需要首先遍历到需要删除的节点，这样的操作就是O（n），其实我们可以直接获得删除节点下一个得位置，再把下一个位置复制给删除节点，再删除刚刚得下一个位置，就是O(1)得时间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &quot;..\Utilities\xsList.h&quot;</span><br><span class="line"></span><br><span class="line">void DeleteNode(ListNode** pListHead, ListNode* pToBeDeleted)</span><br><span class="line">&#123;</span><br><span class="line">    if(!pListHead || !pToBeDeleted)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    // 要删除的结点不是尾结点</span><br><span class="line">    if(pToBeDeleted-&gt;m_pNext != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNext = pToBeDeleted-&gt;m_pNext;</span><br><span class="line">        pToBeDeleted-&gt;m_nValue = pNext-&gt;m_nValue;</span><br><span class="line">        pToBeDeleted-&gt;m_pNext = pNext-&gt;m_pNext;</span><br><span class="line"> </span><br><span class="line">        delete pNext;</span><br><span class="line">        pNext = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    // 链表只有一个结点，删除头结点（也是尾结点）</span><br><span class="line">    else if(*pListHead == pToBeDeleted)</span><br><span class="line">    &#123;</span><br><span class="line">        delete pToBeDeleted;</span><br><span class="line">        pToBeDeleted = nullptr;</span><br><span class="line">        *pListHead = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    // 链表中有多个结点，删除尾结点</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNode = *pListHead;</span><br><span class="line">        while(pNode-&gt;m_pNext != pToBeDeleted)</span><br><span class="line">        &#123;</span><br><span class="line">            pNode = pNode-&gt;m_pNext;            </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        pNode-&gt;m_pNext = nullptr;</span><br><span class="line">        delete pToBeDeleted;</span><br><span class="line">        pToBeDeleted = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="18-调整数组顺序使奇数位于偶数前面"><a href="#18-调整数组顺序使奇数位于偶数前面" class="headerlink" title="18. 调整数组顺序使奇数位于偶数前面"></a>18. 调整数组顺序使奇数位于偶数前面</h3><p> 题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p> 其实我们只要使得所有偶数都在奇数得后面即可</p>
<p> 思路一：我们遍历数组，每当遇到一个偶数就把该偶数放到数组后面，具体做法，每当遇到一个偶数，将该偶数后面得数字往前移动一格，再把该偶数放到末尾。</p>
<p> 思路二：上面的方法每遇到一个偶数就要移动一次，需要O(N2).现在我们设立两个指针i j，分别指向数组得头和尾，如果前面得指针指向偶数，后面得指向奇数，则交换他们。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">void Reorder(int *pData, unsigned int length, bool (*func)(int));</span><br><span class="line">bool isEven(int n);</span><br><span class="line"></span><br><span class="line">// ====================方法一====================</span><br><span class="line">void ReorderOddEven_1(int *pData, unsigned int length)</span><br><span class="line">&#123;</span><br><span class="line">    if(pData == nullptr || length == 0)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    int *pBegin = pData;</span><br><span class="line">    int *pEnd = pData + length - 1;</span><br><span class="line"></span><br><span class="line">    while(pBegin &lt; pEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        // 向后移动pBegin，直到它指向偶数</span><br><span class="line">        while(pBegin &lt; pEnd &amp;&amp; (*pBegin &amp; 0x1) != 0)</span><br><span class="line">            pBegin ++;</span><br><span class="line"></span><br><span class="line">        // 向前移动pEnd，直到它指向奇数</span><br><span class="line">        while(pBegin &lt; pEnd &amp;&amp; (*pEnd &amp; 0x1) == 0)</span><br><span class="line">            pEnd --;</span><br><span class="line"></span><br><span class="line">        if(pBegin &lt; pEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            int temp = *pBegin;</span><br><span class="line">            *pBegin = *pEnd;</span><br><span class="line">            *pEnd = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ====================方法二====================</span><br><span class="line">void ReorderOddEven_2(int *pData, unsigned int length)</span><br><span class="line">&#123;</span><br><span class="line">    Reorder(pData, length, isEven);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Reorder(int *pData, unsigned int length, bool (*func)(int))</span><br><span class="line">&#123;</span><br><span class="line">    if(pData == nullptr || length == 0)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    int *pBegin = pData;</span><br><span class="line">    int *pEnd = pData + length - 1;</span><br><span class="line"></span><br><span class="line">    while(pBegin &lt; pEnd) </span><br><span class="line">    &#123;</span><br><span class="line">        // 向后移动pBegin</span><br><span class="line">        while(pBegin &lt; pEnd &amp;&amp; !func(*pBegin))</span><br><span class="line">            pBegin ++;</span><br><span class="line"></span><br><span class="line">        // 向前移动pEnd</span><br><span class="line">        while(pBegin &lt; pEnd &amp;&amp; func(*pEnd))</span><br><span class="line">            pEnd --;</span><br><span class="line"></span><br><span class="line">        if(pBegin &lt; pEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            int temp = *pBegin;</span><br><span class="line">            *pBegin = *pEnd;</span><br><span class="line">            *pEnd = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isEven(int n)</span><br><span class="line">&#123;</span><br><span class="line">    return (n &amp; 1) == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="22-链表中倒数第k个结点"><a href="#22-链表中倒数第k个结点" class="headerlink" title="22.链表中倒数第k个结点"></a>22.链表中倒数第k个结点</h3><p>题目：输入一个链表，输出该链表中倒数第k个结点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第1个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点是值为4的结点。</p>
<p>由于是单链表，直接找到倒数k个节点是不能的。可是我们可以把找倒数k个，可以想成找正数第n-k+1个，这样只要我们确定了链表长度n即可。但是这种方法需要遍历链表两次（确定链表长度一次）。</p>
<p>只需遍历链表一次的方法：两个指针，初始时两个都在开头，之后一个不动，一个向前走k-1步。然后两者一起动。当在前面的指针先到尾部时，第一个指针就在链表倒数k个位置。 但要注意：链表位空，k=0的情况</p>
<p>这种两个确定距离指针移动来确定链表某个位置的方法很常见。（确定距离快慢指针）</p>
<p>还有一种方法，两个指针初始都在开头，快指针一次走两个，慢指针一次走一个。当快指针到末尾时，慢指针恰好可以到链表中间。（不同速度的快慢指针）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &quot;..\Utilities\List.h&quot;</span><br><span class="line"></span><br><span class="line">ListNode* FindKthToTail(ListNode* pListHead, unsigned int k)</span><br><span class="line">&#123;</span><br><span class="line">    if(pListHead == nullptr || k == 0)</span><br><span class="line">        return nullptr;</span><br><span class="line"></span><br><span class="line">    ListNode *pAhead = pListHead;</span><br><span class="line">    ListNode *pBehind = nullptr;</span><br><span class="line"></span><br><span class="line">    for(unsigned int i = 0; i &lt; k - 1; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pAhead-&gt;m_pNext != nullptr)</span><br><span class="line">            pAhead = pAhead-&gt;m_pNext;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pBehind = pListHead;</span><br><span class="line">    while(pAhead-&gt;m_pNext != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        pAhead = pAhead-&gt;m_pNext;</span><br><span class="line">        pBehind = pBehind-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pBehind;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="23-链表中环的入口结点"><a href="#23-链表中环的入口结点" class="headerlink" title="23.链表中环的入口结点"></a>23.链表中环的入口结点</h3><p>题目：一个链表中包含环，如何找出环的入口结点？例如，在图3.8的链表中，环的入口结点是结点3。</p>
<p>首先我们应该是先判断一个链表是否有环，如果有环再判断入环节点</p>
<p>判断有环：快慢两个指针，快2步，慢一步，如果快走到null，无环。如果快慢相遇则有环。</p>
<p>入环节点其实就是链表倒数第k个节点（环的长度）。这就是上一条题目。所以我们需要先确定环的长度。</p>
<p>确定环的长度：上面已经得到快慢指针相遇的地方，这个相遇的地方一定是在环内，所以继续移动该位置，如果相遇，记录移动的次数就是环的大小。</p>
<p>求入口u节点：相当于求倒数第k的节点。距离固定的快慢指针法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &quot;../Utilities/list.h&quot;</span><br><span class="line"></span><br><span class="line">ListNode* MeetingNode(ListNode* pHead)</span><br><span class="line">&#123;</span><br><span class="line">    if(pHead == nullptr)</span><br><span class="line">        return nullptr;</span><br><span class="line"></span><br><span class="line">    ListNode* pSlow = pHead-&gt;m_pNext;</span><br><span class="line">    if(pSlow == nullptr)</span><br><span class="line">        return nullptr;</span><br><span class="line"></span><br><span class="line">    ListNode* pFast = pSlow-&gt;m_pNext;</span><br><span class="line">    while(pFast != nullptr &amp;&amp; pSlow != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pFast == pSlow)</span><br><span class="line">            return pFast;</span><br><span class="line"></span><br><span class="line">        pSlow = pSlow-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">        pFast = pFast-&gt;m_pNext;</span><br><span class="line">        if(pFast != nullptr)</span><br><span class="line">            pFast = pFast-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode* EntryNodeOfLoop(ListNode* pHead)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode* meetingNode = MeetingNode(pHead);</span><br><span class="line">    if(meetingNode == nullptr)</span><br><span class="line">        return nullptr;</span><br><span class="line"></span><br><span class="line">    // 得到环中结点的数目</span><br><span class="line">    int nodesInLoop = 1;</span><br><span class="line">    ListNode* pNode1 = meetingNode;</span><br><span class="line">    while(pNode1-&gt;m_pNext != meetingNode)</span><br><span class="line">    &#123;</span><br><span class="line">        pNode1 = pNode1-&gt;m_pNext;</span><br><span class="line">        ++nodesInLoop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 先移动pNode1，次数为环中结点的数目</span><br><span class="line">    pNode1 = pHead;</span><br><span class="line">    for(int i = 0; i &lt; nodesInLoop; ++i)</span><br><span class="line">        pNode1 = pNode1-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">    // 再移动pNode1和pNode2</span><br><span class="line">    ListNode* pNode2 = pHead;</span><br><span class="line">    while(pNode1 != pNode2)</span><br><span class="line">    &#123;</span><br><span class="line">        pNode1 = pNode1-&gt;m_pNext;</span><br><span class="line">        pNode2 = pNode2-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pNode1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24.反转链表"></a>24.反转链表</h3><p>题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p>
<p>我们需要定义三种指针：当前遍历到的节点，前一个节点，后一个节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &quot;..\Utilities\List.h&quot;</span><br><span class="line"></span><br><span class="line">ListNode* ReverseList(ListNode* pHead)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode* pReversedHead = nullptr;</span><br><span class="line">    ListNode* pNode = pHead;</span><br><span class="line">    ListNode* pPrev = nullptr;</span><br><span class="line">    while(pNode != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNext = pNode-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">        if(pNext == nullptr)</span><br><span class="line">            pReversedHead = pNode;</span><br><span class="line"></span><br><span class="line">        pNode-&gt;m_pNext = pPrev;</span><br><span class="line"></span><br><span class="line">        pPrev = pNode;</span><br><span class="line">        pNode = pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pReversedHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25.合并两个排序的链表"></a>25.合并两个排序的链表</h3><p>题目：输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。例如输入图3.11中的链表1和链表2，则合并之后的升序链表如链表3所示。</p>
<p>首先我们比较两个链表的头节点，选择较小的头节点加入排序的节点。之后我们继续在两个剩下的链表上找较小的头节点。这就是一个递归的过程。但是要注意空链表的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &quot;..\Utilities\List.h&quot;</span><br><span class="line"></span><br><span class="line">ListNode* Merge(ListNode* pHead1, ListNode* pHead2)</span><br><span class="line">&#123;</span><br><span class="line">    if(pHead1 == nullptr)</span><br><span class="line">        return pHead2;</span><br><span class="line">    else if(pHead2 == nullptr)</span><br><span class="line">        return pHead1;</span><br><span class="line"></span><br><span class="line">    ListNode* pMergedHead = nullptr;</span><br><span class="line"></span><br><span class="line">    if(pHead1-&gt;m_nValue &lt; pHead2-&gt;m_nValue)</span><br><span class="line">    &#123;</span><br><span class="line">        pMergedHead = pHead1;</span><br><span class="line">        pMergedHead-&gt;m_pNext = Merge(pHead1-&gt;m_pNext, pHead2);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        pMergedHead = pHead2;</span><br><span class="line">        pMergedHead-&gt;m_pNext = Merge(pHead1, pHead2-&gt;m_pNext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pMergedHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26.树的子结构"></a>26.树的子结构</h3><p>题目：输入两棵二叉树A和B，判断B是不是A的子结构。</p>
<p>首先我们看B的父节点，然后在A中找是否存在该节点。然后再以此判断。很容易就此写成一个递归的版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">struct BinaryTreeNode</span><br><span class="line">&#123;</span><br><span class="line">    double                 m_dbValue;</span><br><span class="line">    BinaryTreeNode*        m_pLeft;</span><br><span class="line">    BinaryTreeNode*        m_pRight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool DoesTree1HaveTree2(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2);</span><br><span class="line">bool Equal(double num1, double num2);</span><br><span class="line"></span><br><span class="line">bool HasSubtree(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2)</span><br><span class="line">&#123;</span><br><span class="line">    bool result = false;</span><br><span class="line"></span><br><span class="line">    if(pRoot1 != nullptr &amp;&amp; pRoot2 != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        if(Equal(pRoot1-&gt;m_dbValue, pRoot2-&gt;m_dbValue))</span><br><span class="line">            result = DoesTree1HaveTree2(pRoot1, pRoot2);</span><br><span class="line">        if(!result)</span><br><span class="line">            result = HasSubtree(pRoot1-&gt;m_pLeft, pRoot2);</span><br><span class="line">        if(!result)</span><br><span class="line">            result = HasSubtree(pRoot1-&gt;m_pRight, pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool DoesTree1HaveTree2(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2)</span><br><span class="line">&#123;</span><br><span class="line">    if(pRoot2 == nullptr)</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if(pRoot1 == nullptr)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    if(!Equal(pRoot1-&gt;m_dbValue, pRoot2-&gt;m_dbValue))</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    return DoesTree1HaveTree2(pRoot1-&gt;m_pLeft, pRoot2-&gt;m_pLeft) &amp;&amp;</span><br><span class="line">        DoesTree1HaveTree2(pRoot1-&gt;m_pRight, pRoot2-&gt;m_pRight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Equal(double num1, double num2)</span><br><span class="line">&#123;</span><br><span class="line">    if((num1 - num2 &gt; -0.0000001) &amp;&amp; (num1 - num2 &lt; 0.0000001))</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27.二叉树的镜像"></a>27.二叉树的镜像</h3><p>题目：请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>先序遍历这棵树的节点，对于遍历到的每一个节点，如果它有子节点，就交换它的子节点。直到交换完所有非叶子节点的子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &quot;..\Utilities\BinaryTree.h&quot;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line"></span><br><span class="line">void MirrorRecursively(BinaryTreeNode *pNode)</span><br><span class="line">&#123;</span><br><span class="line">    if((pNode == nullptr) || (pNode-&gt;m_pLeft == nullptr &amp;&amp; pNode-&gt;m_pRight))</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode *pTemp = pNode-&gt;m_pLeft;</span><br><span class="line">    pNode-&gt;m_pLeft = pNode-&gt;m_pRight;</span><br><span class="line">    pNode-&gt;m_pRight = pTemp;</span><br><span class="line">    </span><br><span class="line">    if(pNode-&gt;m_pLeft)</span><br><span class="line">        MirrorRecursively(pNode-&gt;m_pLeft);  </span><br><span class="line"></span><br><span class="line">    if(pNode-&gt;m_pRight)</span><br><span class="line">        MirrorRecursively(pNode-&gt;m_pRight); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MirrorIteratively(BinaryTreeNode* pRoot)</span><br><span class="line">&#123;</span><br><span class="line">    if(pRoot == nullptr)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    std::stack&lt;BinaryTreeNode*&gt; stackTreeNode;</span><br><span class="line">    stackTreeNode.push(pRoot);</span><br><span class="line"></span><br><span class="line">    while(stackTreeNode.size() &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode *pNode = stackTreeNode.top();</span><br><span class="line">        stackTreeNode.pop();</span><br><span class="line"></span><br><span class="line">        BinaryTreeNode *pTemp = pNode-&gt;m_pLeft;</span><br><span class="line">        pNode-&gt;m_pLeft = pNode-&gt;m_pRight;</span><br><span class="line">        pNode-&gt;m_pRight = pTemp;</span><br><span class="line"></span><br><span class="line">        if(pNode-&gt;m_pLeft)</span><br><span class="line">            stackTreeNode.push(pNode-&gt;m_pLeft);</span><br><span class="line"></span><br><span class="line">        if(pNode-&gt;m_pRight)</span><br><span class="line">            stackTreeNode.push(pNode-&gt;m_pRight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28.对称的二叉树"></a>28.对称的二叉树</h3><p>题目：请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>第一个思路，既然判断一棵二叉树对称是看他是否和他的镜像一样，那么我们可以借助上面的方法，先构建这颗树的镜像，再依次判断两个树是否一样。</p>
<p>第二个思路，先序遍历都是根左右，如果另一只先序遍历是根右左，如果这两种遍历结果一样，则对称。但是存在一种情况，就是所有节点都一样但结构不一样，所以我们需要在遍历的过程中，也要遍历入nullptr<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &quot;../Utilities/BinaryTree.h&quot;</span><br><span class="line"></span><br><span class="line">bool isSymmetrical(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2);</span><br><span class="line"></span><br><span class="line">bool isSymmetrical(BinaryTreeNode* pRoot)</span><br><span class="line">&#123;</span><br><span class="line">    return isSymmetrical(pRoot, pRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isSymmetrical(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2)</span><br><span class="line">&#123;</span><br><span class="line">    if(pRoot1 == nullptr &amp;&amp; pRoot2 == nullptr)</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if(pRoot1 == nullptr || pRoot2 == nullptr)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    if(pRoot1-&gt;m_nValue != pRoot2-&gt;m_nValue)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    return isSymmetrical(pRoot1-&gt;m_pLeft, pRoot2-&gt;m_pRight)</span><br><span class="line">        &amp;&amp; isSymmetrical(pRoot1-&gt;m_pRight, pRoot2-&gt;m_pLeft);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29.顺时针打印矩阵"></a>29.顺时针打印矩阵</h3><p>题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>将整个问题分解开，打印整个矩阵，相当于一圈圈剥开矩阵，一圈一圈剥开又可以分解成4个不同方向留一个输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">void PrintMatrixInCircle(int** numbers, int columns, int rows, int start);</span><br><span class="line">void printNumber(int number);</span><br><span class="line"></span><br><span class="line">void PrintMatrixClockwisely(int** numbers, int columns, int rows)</span><br><span class="line">&#123;</span><br><span class="line">    if(numbers == nullptr || columns &lt;= 0 || rows &lt;= 0)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    int start = 0;</span><br><span class="line"></span><br><span class="line">    while(columns &gt; start * 2 &amp;&amp; rows &gt; start * 2)</span><br><span class="line">    &#123;</span><br><span class="line">        PrintMatrixInCircle(numbers, columns, rows, start);</span><br><span class="line"></span><br><span class="line">        ++start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PrintMatrixInCircle(int** numbers, int columns, int rows, int start)</span><br><span class="line">&#123;</span><br><span class="line">    int endX = columns - 1 - start;</span><br><span class="line">    int endY = rows - 1 - start;</span><br><span class="line"></span><br><span class="line">    // 从左到右打印一行</span><br><span class="line">    for(int i = start; i &lt;= endX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int number = numbers[start][i];</span><br><span class="line">        printNumber(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从上到下打印一列</span><br><span class="line">    if(start &lt; endY)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = start + 1; i &lt;= endY; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            int number = numbers[i][endX];</span><br><span class="line">            printNumber(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从右到左打印一行</span><br><span class="line">    if(start &lt; endX &amp;&amp; start &lt; endY)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = endX - 1; i &gt;= start; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            int number = numbers[endY][i];</span><br><span class="line">            printNumber(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从下到上打印一行</span><br><span class="line">    if(start &lt; endX &amp;&amp; start &lt; endY - 1)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = endY - 1; i &gt;= start + 1; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            int number = numbers[i][start];</span><br><span class="line">            printNumber(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printNumber(int number)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d\t&quot;, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30.包含min函数的栈"></a>30.包含min函数的栈</h3><p>题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O(1)。</p>
<p>使用两个栈，一个Data栈，一个min栈。初始时两个为空，data压入一个数字，该数字同时压入min。data再进一个数字，该数字与min的栈顶比较，如果该数字更小，压入该数字。如果min栈栈顶更小，则重复压入栈顶。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; class StackWithMin</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    StackWithMin() &#123;&#125;</span><br><span class="line">    virtual ~StackWithMin() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    T&amp; top();</span><br><span class="line">    const T&amp; top() const;</span><br><span class="line"></span><br><span class="line">    void push(const T&amp; value);</span><br><span class="line">    void pop();</span><br><span class="line"></span><br><span class="line">    const T&amp; min() const;</span><br><span class="line"></span><br><span class="line">    bool empty() const;</span><br><span class="line">    size_t size() const;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::stack&lt;T&gt;   m_data;     // 数据栈，存放栈的所有元素</span><br><span class="line">    std::stack&lt;T&gt;   m_min;      // 辅助栈，存放栈的最小元素</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; void StackWithMin&lt;T&gt;::push(const T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    // 把新元素添加到辅助栈</span><br><span class="line">    m_data.push(value);</span><br><span class="line"></span><br><span class="line">    // 当新元素比之前的最小元素小时，把新元素插入辅助栈里；</span><br><span class="line">    // 否则把之前的最小元素重复插入辅助栈里</span><br><span class="line">    if(m_min.size() == 0 || value &lt; m_min.top())</span><br><span class="line">        m_min.push(value);</span><br><span class="line">    else</span><br><span class="line">        m_min.push(m_min.top());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; void StackWithMin&lt;T&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line">    assert(m_data.size() &gt; 0 &amp;&amp; m_min.size() &gt; 0);</span><br><span class="line"></span><br><span class="line">    m_data.pop();</span><br><span class="line">    m_min.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; const T&amp; StackWithMin&lt;T&gt;::min() const</span><br><span class="line">&#123;</span><br><span class="line">    assert(m_data.size() &gt; 0 &amp;&amp; m_min.size() &gt; 0);</span><br><span class="line"></span><br><span class="line">    return m_min.top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; T&amp; StackWithMin&lt;T&gt;::top()</span><br><span class="line">&#123;</span><br><span class="line">    return m_data.top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; const T&amp; StackWithMin&lt;T&gt;::top() const</span><br><span class="line">&#123;</span><br><span class="line">    return m_data.top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; bool StackWithMin&lt;T&gt;::empty() const</span><br><span class="line">&#123;</span><br><span class="line">    return m_data.empty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; size_t StackWithMin&lt;T&gt;::size() const</span><br><span class="line">&#123;</span><br><span class="line">    return m_data.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="32-不分行从上往下打印二叉树"><a href="#32-不分行从上往下打印二叉树" class="headerlink" title="32 不分行从上往下打印二叉树"></a>32 不分行从上往下打印二叉树</h3><p>实际就是二叉树的层序遍历，层序遍历是宽度优先，用队列模拟实现。根节点入队，访问队头，退队，同时把对头的子节点入队。之后仍然是访问队头，退队，入子节点。直到队空。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &quot;..\Utilities\BinaryTree.h&quot;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line"></span><br><span class="line">void PrintFromTopToBottom(BinaryTreeNode* pRoot)</span><br><span class="line">&#123;</span><br><span class="line">    if(pRoot == nullptr)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    std::deque&lt;BinaryTreeNode *&gt; dequeTreeNode;</span><br><span class="line"></span><br><span class="line">    dequeTreeNode.push_back(pRoot);</span><br><span class="line"></span><br><span class="line">    while(dequeTreeNode.size())</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode *pNode = dequeTreeNode.front();</span><br><span class="line">        dequeTreeNode.pop_front();</span><br><span class="line"></span><br><span class="line">        printf(&quot;%d &quot;, pNode-&gt;m_nValue);</span><br><span class="line"></span><br><span class="line">        if(pNode-&gt;m_pLeft)</span><br><span class="line">            dequeTreeNode.push_back(pNode-&gt;m_pLeft);</span><br><span class="line"></span><br><span class="line">        if(pNode-&gt;m_pRight)</span><br><span class="line">            dequeTreeNode.push_back(pNode-&gt;m_pRight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33.二叉搜索树的后序遍历序列"></a>33.二叉搜索树的后序遍历序列</h3><p>题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。</p>
<p>后序遍历，最后一个值就是根节点。然后前面部分一半是左子树，一半是右子树。由于是搜索树，所以左子树应该所有节点小于根，右子树所有节点大于根。然后再递归的再这两颗子树上判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">// BST：Binary Search Tree，二叉搜索树</span><br><span class="line">bool VerifySquenceOfBST(int sequence[], int length)</span><br><span class="line">&#123;</span><br><span class="line">    if(sequence == nullptr || length &lt;= 0)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    int root = sequence[length - 1];</span><br><span class="line"></span><br><span class="line">    // 在二叉搜索树中左子树的结点小于根结点</span><br><span class="line">    int i = 0;</span><br><span class="line">    for(; i &lt; length - 1; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(sequence[i] &gt; root)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在二叉搜索树中右子树的结点大于根结点</span><br><span class="line">    int j = i;</span><br><span class="line">    for(; j &lt; length - 1; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        if(sequence[j] &lt; root)</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断左子树是不是二叉搜索树</span><br><span class="line">    bool left = true;</span><br><span class="line">    if(i &gt; 0)</span><br><span class="line">        left = VerifySquenceOfBST(sequence, i);</span><br><span class="line"></span><br><span class="line">    // 判断右子树是不是二叉搜索树</span><br><span class="line">    bool right = true;</span><br><span class="line">    if(i &lt; length - 1)</span><br><span class="line">        right = VerifySquenceOfBST(sequence + i, length - i - 1);</span><br><span class="line"></span><br><span class="line">    return (left &amp;&amp; right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34 二叉树中和为某一值的路径"></a>34 二叉树中和为某一值的路径</h3><p>题目：输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p>用前序遍历的方式访问节点，并以此建立二叉树的路径。当我们访问到一个节点时，我们把这个节点加入到路径里。并累加该节点的值。如果当前节点是叶子节点，并且路径值正好是输入整数，则打印。如果不是叶子节点，则遍历子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &quot;..\Utilities\BinaryTree.h&quot;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">void FindPath(BinaryTreeNode* pRoot, int expectedSum, std::vector&lt;int&gt;&amp; path, int&amp; currentSum);</span><br><span class="line"></span><br><span class="line">void FindPath(BinaryTreeNode* pRoot, int expectedSum)</span><br><span class="line">&#123;</span><br><span class="line">    if(pRoot == nullptr)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;int&gt; path;</span><br><span class="line">    int currentSum = 0;</span><br><span class="line">    FindPath(pRoot, expectedSum, path, currentSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void FindPath</span><br><span class="line">(</span><br><span class="line">    BinaryTreeNode*   pRoot,        </span><br><span class="line">    int               expectedSum,  </span><br><span class="line">    std::vector&lt;int&gt;&amp; path,         </span><br><span class="line">    int&amp;              currentSum</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    currentSum += pRoot-&gt;m_nValue;</span><br><span class="line">    path.push_back(pRoot-&gt;m_nValue);</span><br><span class="line"></span><br><span class="line">    // 如果是叶结点，并且路径上结点的和等于输入的值</span><br><span class="line">    // 打印出这条路径</span><br><span class="line">    bool isLeaf = pRoot-&gt;m_pLeft == nullptr &amp;&amp; pRoot-&gt;m_pRight == nullptr;</span><br><span class="line">    if(currentSum == expectedSum &amp;&amp; isLeaf)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;A path is found: &quot;);</span><br><span class="line">        std::vector&lt;int&gt;::iterator iter = path.begin();</span><br><span class="line">        for(; iter != path.end(); ++ iter)</span><br><span class="line">            printf(&quot;%d\t&quot;, *iter);</span><br><span class="line">        </span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果不是叶结点，则遍历它的子结点</span><br><span class="line">    if(pRoot-&gt;m_pLeft != nullptr)</span><br><span class="line">        FindPath(pRoot-&gt;m_pLeft, expectedSum, path, currentSum);</span><br><span class="line">    if(pRoot-&gt;m_pRight != nullptr)</span><br><span class="line">        FindPath(pRoot-&gt;m_pRight, expectedSum, path, currentSum);</span><br><span class="line"></span><br><span class="line">    // 在返回到父结点之前，在路径上删除当前结点，</span><br><span class="line">    // 并在currentSum中减去当前结点的值</span><br><span class="line">    currentSum -= pRoot-&gt;m_nValue;</span><br><span class="line">    path.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36.二叉搜索树与双向链表"></a>36.二叉搜索树与双向链表</h3><p> 题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p> 二叉搜索树的中序遍历方式其实就是有序的。最主要的是根节点需要最后与左子树最左边的节点，右子树最左边的节点相连。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;cstdio&gt;</span><br><span class="line">#include &quot;..\Utilities\BinaryTree.h&quot;</span><br><span class="line"></span><br><span class="line">void ConvertNode(BinaryTreeNode* pNode, BinaryTreeNode** pLastNodeInList);</span><br><span class="line"></span><br><span class="line">BinaryTreeNode* Convert(BinaryTreeNode* pRootOfTree)</span><br><span class="line">&#123;</span><br><span class="line">    BinaryTreeNode *pLastNodeInList = nullptr;</span><br><span class="line">    ConvertNode(pRootOfTree, &amp;pLastNodeInList);</span><br><span class="line"></span><br><span class="line">    // pLastNodeInList指向双向链表的尾结点，</span><br><span class="line">    // 我们需要返回头结点</span><br><span class="line">    BinaryTreeNode *pHeadOfList = pLastNodeInList;</span><br><span class="line">    while(pHeadOfList != nullptr &amp;&amp; pHeadOfList-&gt;m_pLeft != nullptr)</span><br><span class="line">        pHeadOfList = pHeadOfList-&gt;m_pLeft;</span><br><span class="line"></span><br><span class="line">    return pHeadOfList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ConvertNode(BinaryTreeNode* pNode, BinaryTreeNode** pLastNodeInList)</span><br><span class="line">&#123;</span><br><span class="line">    if(pNode == nullptr)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode *pCurrent = pNode;</span><br><span class="line"></span><br><span class="line">    if (pCurrent-&gt;m_pLeft != nullptr)</span><br><span class="line">        ConvertNode(pCurrent-&gt;m_pLeft, pLastNodeInList);</span><br><span class="line"></span><br><span class="line">    pCurrent-&gt;m_pLeft = *pLastNodeInList; </span><br><span class="line">    if(*pLastNodeInList != nullptr)</span><br><span class="line">        (*pLastNodeInList)-&gt;m_pRight = pCurrent;</span><br><span class="line"></span><br><span class="line">    *pLastNodeInList = pCurrent;</span><br><span class="line"></span><br><span class="line">    if (pCurrent-&gt;m_pRight != nullptr)</span><br><span class="line">        ConvertNode(pCurrent-&gt;m_pRight, pLastNodeInList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="38-字符串的全排列"><a href="#38-字符串的全排列" class="headerlink" title="38 字符串的全排列"></a>38 字符串的全排列</h3><p>题目：输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。</p>
<p>这题思路是这样的，给定的字符串是abc，那么第一步首先圈出a是第一个字符，把a与后面的所有字符换位置，那么一共有3个：abc,bac,cba,<br>之后，再对剩下的位置采用一样的方法，确定第一个位置，把第一个位置与剩下的互换。abc，剩下bc，确定第一个字符b，依次与剩余的互换，得到acb。 所以基本方式就是把字符串分割成两部分，一部分是第一个字符，一部分是剩余的字符。然后把第一个字符与剩下的互换。之后对剩下的采用同样的方法。很显然可以采用递归。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">void Permutation(char* pStr, char* pBegin);</span><br><span class="line"></span><br><span class="line">void Permutation(char* pStr)</span><br><span class="line">&#123;</span><br><span class="line">    if(pStr == nullptr)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    Permutation(pStr, pStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Permutation(char* pStr, char* pBegin)</span><br><span class="line">&#123;</span><br><span class="line">    if(*pBegin == &apos;\0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%s\n&quot;, pStr);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for(char* pCh = pBegin; *pCh != &apos;\0&apos;; ++ pCh)</span><br><span class="line">        &#123;</span><br><span class="line">            char temp = *pCh;</span><br><span class="line">            *pCh = *pBegin;</span><br><span class="line">            *pBegin = temp;</span><br><span class="line"></span><br><span class="line">            Permutation(pStr, pBegin + 1);</span><br><span class="line"></span><br><span class="line">            temp = *pCh;</span><br><span class="line">            *pCh = *pBegin;</span><br><span class="line">            *pBegin = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39.数组中出现次数超过一半的数字"></a>39.数组中出现次数超过一半的数字</h3><p>题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1, 2, 3, 2, 2, 2, 5, 4, 2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。</p>
<p>次数超过一半，那么如果这个数组是有序的，那么中位数就是那个数。可是这里没有序。我们可以借助快排的思想。随机找一个数，找到其有序点。如果左右长度相等，那么这个数就是我们要找的。如果不是，则在较长的一端继续这样。直到有一次两边是相等的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &quot;..\Utilities\Array.h&quot;</span><br><span class="line"></span><br><span class="line">bool g_bInputInvalid = false;</span><br><span class="line"></span><br><span class="line">bool CheckInvalidArray(int* numbers, int length)</span><br><span class="line">&#123;</span><br><span class="line">    g_bInputInvalid = false;</span><br><span class="line">    if(numbers == nullptr &amp;&amp; length &lt;= 0)</span><br><span class="line">        g_bInputInvalid = true;</span><br><span class="line"></span><br><span class="line">    return g_bInputInvalid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool CheckMoreThanHalf(int* numbers, int length, int number)</span><br><span class="line">&#123;</span><br><span class="line">    int times = 0;</span><br><span class="line">    for(int i = 0; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(numbers[i] == number)</span><br><span class="line">            times++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    bool isMoreThanHalf = true;</span><br><span class="line">    if(times * 2 &lt;= length)</span><br><span class="line">    &#123;</span><br><span class="line">        g_bInputInvalid = true;</span><br><span class="line">        isMoreThanHalf = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return isMoreThanHalf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="40-最小的k个数"><a href="#40-最小的k个数" class="headerlink" title="40.最小的k个数"></a>40.最小的k个数</h3><p>题目：输入n个整数，找出其中最小的k个数。例如输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<p>第一种思路，和前面找超过一半的一样，基于partition，只要我们找到一个partition为k-1的位置，那么该位置前面就是最小的k个，只是没有顺序。所以我们可以递归的找partition。如果当前找的partion大于k-1，则把end设为该partion，在这一段继续找。如果小于，则把start设为该位置。在后面继续找，直到找到partition。但是这种方法需要改变输入数组。并且需要把整个数组内存读入。</p>
<p>第二种思路，设一个大小为k的容器，先读入数组前k的数字。此时容器满，后面每读入一个数字，1.找到当前容器最大值 2.比较读入的数字与该最大值，若小于最大值，则把读入的值插入，删除之前的最大值。  该容器可以用堆实现。可以直接使用STL里的multiset（set本身有序且查找复杂度很低）。这种方法可以针对海量数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &quot;..\Utilities\Array.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// ====================方法1====================</span><br><span class="line">void GetLeastNumbers_Solution1(int* input, int n, int* output, int k)</span><br><span class="line">&#123;</span><br><span class="line">    if(input == nullptr || output == nullptr || k &gt; n || n &lt;= 0 || k &lt;= 0)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    int start = 0;</span><br><span class="line">    int end = n - 1;</span><br><span class="line">    int index = Partition(input, n, start, end);</span><br><span class="line">    while(index != k - 1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(index &gt; k - 1)</span><br><span class="line">        &#123;</span><br><span class="line">            end = index - 1;</span><br><span class="line">            index = Partition(input, n, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            start = index + 1;</span><br><span class="line">            index = Partition(input, n, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; k; ++i)</span><br><span class="line">        output[i] = input[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ====================方法2====================</span><br><span class="line">typedef multiset&lt;int, std::greater&lt;int&gt; &gt;            intSet;</span><br><span class="line">typedef multiset&lt;int, std::greater&lt;int&gt; &gt;::iterator  setIterator;</span><br><span class="line"></span><br><span class="line">void GetLeastNumbers_Solution2(const vector&lt;int&gt;&amp; data, intSet&amp; leastNumbers, int k)</span><br><span class="line">&#123;</span><br><span class="line">    leastNumbers.clear();</span><br><span class="line"></span><br><span class="line">    if(k &lt; 1 || data.size() &lt; k)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;::const_iterator iter = data.begin();</span><br><span class="line">    for(; iter != data.end(); ++ iter)</span><br><span class="line">    &#123;</span><br><span class="line">        if((leastNumbers.size()) &lt; k)</span><br><span class="line">            leastNumbers.insert(*iter);</span><br><span class="line"></span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            setIterator iterGreatest = leastNumbers.begin();</span><br><span class="line"></span><br><span class="line">            if(*iter &lt; *(leastNumbers.begin()))</span><br><span class="line">            &#123;</span><br><span class="line">                leastNumbers.erase(iterGreatest);</span><br><span class="line">                leastNumbers.insert(*iter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42.连续子数组的最大和"></a>42.连续子数组的最大和</h3><p>题目：输入一个整型数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。</p>
<p>如果列出所有排列，n(n-1)/2,复杂度高。基于动态规划的思想，计算f(i)如果前面f(i-1)是负数，看Data(i)时，不需要考虑f(i-1),直接从Data(i)开始。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">bool g_InvalidInput = false;</span><br><span class="line"></span><br><span class="line">int FindGreatestSumOfSubArray(int *pData, int nLength)</span><br><span class="line">&#123;</span><br><span class="line">    if((pData == nullptr) || (nLength &lt;= 0))</span><br><span class="line">    &#123;</span><br><span class="line">        g_InvalidInput = true;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_InvalidInput = false;</span><br><span class="line"></span><br><span class="line">    int nCurSum = 0;</span><br><span class="line">    int nGreatestSum = 0x80000000;</span><br><span class="line">    for(int i = 0; i &lt; nLength; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(nCurSum &lt;= 0)</span><br><span class="line">            nCurSum = pData[i];</span><br><span class="line">        else</span><br><span class="line">            nCurSum += pData[i];</span><br><span class="line"></span><br><span class="line">        if(nCurSum &gt; nGreatestSum)</span><br><span class="line">            nGreatestSum = nCurSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nGreatestSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="50-字符串中第一个只出现一次的字符"><a href="#50-字符串中第一个只出现一次的字符" class="headerlink" title="50.字符串中第一个只出现一次的字符"></a>50.字符串中第一个只出现一次的字符</h3><p>题目：在字符串中找出第一个只出现一次的字符。如输入”abaccdeff”，则输出’b’。</p>
<p>利用哈希表，第一个遍历时，key记录字符。value记录出现次数。第二次遍历时，遍历到第一个value为1的字符则输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">char FirstNotRepeatingChar(const char* pString)</span><br><span class="line">&#123;</span><br><span class="line">    if(pString == nullptr)</span><br><span class="line">        return &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">    const int tableSize = 256;</span><br><span class="line">    unsigned int hashTable[tableSize];</span><br><span class="line">    for(unsigned int i = 0; i &lt; tableSize; ++i)</span><br><span class="line">        hashTable[i] = 0;</span><br><span class="line"></span><br><span class="line">    const char* pHashKey = pString;</span><br><span class="line">    while(*(pHashKey) != &apos;\0&apos;)</span><br><span class="line">        hashTable[*(pHashKey++)] ++;</span><br><span class="line"></span><br><span class="line">    pHashKey = pString;</span><br><span class="line">    while(*pHashKey != &apos;\0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(hashTable[*pHashKey] == 1)</span><br><span class="line">            return *pHashKey;</span><br><span class="line"></span><br><span class="line">        pHashKey++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &apos;\0&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="52-两个链表的第一个公共结点"><a href="#52-两个链表的第一个公共结点" class="headerlink" title="52.两个链表的第一个公共结点"></a>52.两个链表的第一个公共结点</h3><p>题目：输入两个链表，找出它们的第一个公共结点。</p>
<p>相交链表是什么样子的，他们的尾部肯定是相同的。但是单向链表无法从尾部访问。</p>
<p>第一种思路：利用两个辅助栈，把两个链表分别入栈，然后同时弹栈，谈一次比较一次。即可。但是需要辅助站。</p>
<p>第二种思路：首先遍历两个链表，得到两个链表的长度n和m，得到差值后，把长的链表先走差值步，之后两者同时走。依次比较<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &quot;..\Utilities\List.h&quot;</span><br><span class="line"></span><br><span class="line">unsigned int GetListLength(ListNode* pHead);</span><br><span class="line"></span><br><span class="line">ListNode* FindFirstCommonNode(ListNode *pHead1, ListNode *pHead2)</span><br><span class="line">&#123;</span><br><span class="line">    // 得到两个链表的长度</span><br><span class="line">    unsigned int nLength1 = GetListLength(pHead1);</span><br><span class="line">    unsigned int nLength2 = GetListLength(pHead2);</span><br><span class="line">    int nLengthDif = nLength1 - nLength2;</span><br><span class="line"></span><br><span class="line">    ListNode* pListHeadLong = pHead1;</span><br><span class="line">    ListNode* pListHeadShort = pHead2;</span><br><span class="line">    if(nLength2 &gt; nLength1)</span><br><span class="line">    &#123;</span><br><span class="line">        pListHeadLong = pHead2;</span><br><span class="line">        pListHeadShort = pHead1;</span><br><span class="line">        nLengthDif = nLength2 - nLength1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 先在长链表上走几步，再同时在两个链表上遍历</span><br><span class="line">    for(int i = 0; i &lt; nLengthDif; ++i)</span><br><span class="line">        pListHeadLong = pListHeadLong-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">    while((pListHeadLong != nullptr) &amp;&amp;</span><br><span class="line">        (pListHeadShort != nullptr) &amp;&amp;</span><br><span class="line">        (pListHeadLong != pListHeadShort))</span><br><span class="line">    &#123;</span><br><span class="line">        pListHeadLong = pListHeadLong-&gt;m_pNext;</span><br><span class="line">        pListHeadShort = pListHeadShort-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 得到第一个公共结点</span><br><span class="line">    ListNode* pFisrtCommonNode = pListHeadLong;</span><br><span class="line"></span><br><span class="line">    return pFisrtCommonNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned int GetListLength(ListNode* pHead)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int nLength = 0;</span><br><span class="line">    ListNode* pNode = pHead;</span><br><span class="line">    while(pNode != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        ++nLength;</span><br><span class="line">        pNode = pNode-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="53-在排序数组中查找数字"><a href="#53-在排序数组中查找数字" class="headerlink" title="53.在排序数组中查找数字"></a>53.在排序数组中查找数字</h3><p>题目1：数字在排序数组中出现的次数:统计一个数字在排序数组中出现的次数。例如输入排序数组{1, 2, 3, 3, 3, 3, 4, 5}和数字3，由于3在这个数组中出现了4次，因此输出4。</p>
<p>在一个有序数组里，找某个数字出现的次数。直接遍历复杂度O(N)。有序数组查找问题，一定切记使用二分搜索法。有序数组找一个数字出现次数，由于有序，那么这些数字一定是连续在一起的。那么只要我们找到了最右边的一个3，和最左边的一个3.那么相应的长度就知道了。1.有序数组找最左边的一个3，二分，如果中间值大于3，那么就在左边继续找，如果中间值小于3那么在右边找。如果中间值等于3，那么看这个中间值左边是否是3，如果不是，那么找到了最左边的3，如果中间值左边也是3，那么还是在左边继续找。2.有序数组中找右边的3过程和上面一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">int GetFirstK(const int* data, int length, int k, int start, int end);</span><br><span class="line">int GetLastK(const int* data, int length, int k, int start, int end);</span><br><span class="line"></span><br><span class="line">int GetNumberOfK(const int* data, int length, int k)</span><br><span class="line">&#123;</span><br><span class="line">    int number = 0;</span><br><span class="line"></span><br><span class="line">    if(data != nullptr &amp;&amp; length &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        int first = GetFirstK(data, length, k, 0, length - 1);</span><br><span class="line">        int last = GetLastK(data, length, k, 0, length - 1);</span><br><span class="line">        </span><br><span class="line">        if(first &gt; -1 &amp;&amp; last &gt; -1)</span><br><span class="line">            number = last - first + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 找到数组中第一个k的下标。如果数组中不存在k，返回-1</span><br><span class="line">int GetFirstK(const int* data, int length, int k, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">    if(start &gt; end)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    int middleIndex = (start + end) / 2;</span><br><span class="line">    int middleData = data[middleIndex];</span><br><span class="line"></span><br><span class="line">    if(middleData == k)</span><br><span class="line">    &#123;</span><br><span class="line">        if((middleIndex &gt; 0 &amp;&amp; data[middleIndex - 1] != k) </span><br><span class="line">            || middleIndex == 0)</span><br><span class="line">            return middleIndex;</span><br><span class="line">        else</span><br><span class="line">            end  = middleIndex - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(middleData &gt; k)</span><br><span class="line">        end = middleIndex - 1;</span><br><span class="line">    else</span><br><span class="line">        start = middleIndex + 1;</span><br><span class="line"></span><br><span class="line">    return GetFirstK(data, length, k, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 找到数组中最后一个k的下标。如果数组中不存在k，返回-1</span><br><span class="line">int GetLastK(const int* data, int length, int k, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">    if(start &gt; end)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    int middleIndex = (start + end) / 2;</span><br><span class="line">    int middleData = data[middleIndex];</span><br><span class="line"></span><br><span class="line">    if(middleData == k)</span><br><span class="line">    &#123;</span><br><span class="line">        if((middleIndex &lt; length - 1 &amp;&amp; data[middleIndex + 1] != k) </span><br><span class="line">            || middleIndex == length - 1)</span><br><span class="line">            return middleIndex;</span><br><span class="line">        else</span><br><span class="line">            start  = middleIndex + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(middleData &lt; k)</span><br><span class="line">        start = middleIndex + 1;</span><br><span class="line">    else</span><br><span class="line">        end = middleIndex - 1;</span><br><span class="line"></span><br><span class="line">    return GetLastK(data, length, k, start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>题目2：0到n-1中缺失的数字：一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0到n-1之内。在范围0到n-1的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<p>长度n-1，数字范围0-n-1，并且有序。说明在那个缺失值之前，数字和其下标是相同的，之后数字和缺失值差一；那么我们只要在有序数组中找到第一个数字和缺失值差1的位置即可。仍然采用二分，如果中间值等于小标，那么继续在右边查找。如果中间值和下标差一，那么看他前一个数字，如果签一个数字和下标相等，那么中间值就是那个值。如果前一个数还是和下标差一，那么继续在左边查找。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">int GetMissingNumber(const int* numbers, int length)</span><br><span class="line">&#123;</span><br><span class="line">    if(numbers == nullptr || length &lt;= 0)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = length - 1;</span><br><span class="line">    while(left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        int middle = (right + left) &gt;&gt; 1;</span><br><span class="line">        if(numbers[middle] != middle)</span><br><span class="line">        &#123;</span><br><span class="line">            if(middle == 0 || numbers[middle - 1] == middle - 1)</span><br><span class="line">                return middle;</span><br><span class="line">            right = middle - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            left = middle + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(left == length)</span><br><span class="line">        return length;</span><br><span class="line"></span><br><span class="line">    // 无效的输入，比如数组不是按要求排序的，</span><br><span class="line">    // 或者有数字不在0到n-1范围之内</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>题目：假设一个单调递增的数组里的每个元素都是整数并且是唯一的。请编程实现一个函数找出数组中任意一个数值等于其下标的元素。例如，在数组{-3, -1, 1, 3, 5}中，数字3和它的下标相等。</p>
<p>递增有序数组查找，二分。中间值恰好等于下标，输出。中间值大于下标，由于递增，那么右边的数字依然大于下标。所以在左边继续找。如果小与下标，那么说明左边都小于，则在右边继续找。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">int GetNumberSameAsIndex(const int* numbers, int length)</span><br><span class="line">&#123;</span><br><span class="line">    if(numbers == nullptr || length &lt;= 0)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = length - 1;</span><br><span class="line">    while(left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        int middle = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">        if(numbers[middle] == middle)</span><br><span class="line">            return middle;</span><br><span class="line"></span><br><span class="line">        if(numbers[middle] &gt; middle)</span><br><span class="line">            right = middle - 1;</span><br><span class="line">        else</span><br><span class="line">            left = middle + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="54-二叉搜索树的第k个结点"><a href="#54-二叉搜索树的第k个结点" class="headerlink" title="54.二叉搜索树的第k个结点"></a>54.二叉搜索树的第k个结点</h3><p>题目：给定一棵二叉搜索树，请找出其中的第k大的结点。</p>
<p>二叉搜索树的中序遍历其实就是一个有序数组，那么就很容易找到第k个节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &quot;../Utilities/BinaryTree.h&quot;</span><br><span class="line"></span><br><span class="line">const BinaryTreeNode* KthNodeCore(const BinaryTreeNode* pRoot, unsigned int&amp; k);</span><br><span class="line"></span><br><span class="line">const BinaryTreeNode* KthNode(const BinaryTreeNode* pRoot, unsigned int k)</span><br><span class="line">&#123;</span><br><span class="line">    if(pRoot == nullptr || k == 0)</span><br><span class="line">        return nullptr;</span><br><span class="line"></span><br><span class="line">    return KthNodeCore(pRoot, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const BinaryTreeNode* KthNodeCore(const BinaryTreeNode* pRoot, unsigned int&amp; k)</span><br><span class="line">&#123;</span><br><span class="line">    const BinaryTreeNode* target = nullptr;</span><br><span class="line"></span><br><span class="line">    if(pRoot-&gt;m_pLeft != nullptr)</span><br><span class="line">        target = KthNodeCore(pRoot-&gt;m_pLeft, k);</span><br><span class="line"></span><br><span class="line">    if(target == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        if(k == 1)</span><br><span class="line">            target = pRoot;</span><br><span class="line"></span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(target == nullptr &amp;&amp; pRoot-&gt;m_pRight != nullptr)</span><br><span class="line">        target = KthNodeCore(pRoot-&gt;m_pRight, k);</span><br><span class="line"></span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="55-二叉树的深度"><a href="#55-二叉树的深度" class="headerlink" title="55.二叉树的深度"></a>55.二叉树的深度</h3><p>题目：输入一棵二叉树的根结点，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>我们可以用递归分解的思想，如果一棵树只有根节点，那么长度就是1.如果一个节点只有右子树，那么深度就是右子树深度加一。如果只有左子树，那么深度就是左子树深度加一。如果同时由左子树和右子树，那么深度就是左右子树深度较大值加1.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &quot;..\Utilities\BinaryTree.h&quot;</span><br><span class="line"></span><br><span class="line">int TreeDepth(const BinaryTreeNode* pRoot)</span><br><span class="line">&#123;</span><br><span class="line">    if(pRoot == nullptr)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int nLeft = TreeDepth(pRoot-&gt;m_pLeft);</span><br><span class="line">    int nRight = TreeDepth(pRoot-&gt;m_pRight);</span><br><span class="line"></span><br><span class="line">    return (nLeft &gt; nRight) ? (nLeft + 1) : (nRight + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>判断平衡二叉树：分解成计算左右子树的深度，看差值是否大于1.</p>
<h3 id="57-和为s的两个数字"><a href="#57-和为s的两个数字" class="headerlink" title="57.和为s的两个数字"></a>57.和为s的两个数字</h3><p>题目：输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，输出任意一对即可。</p>
<p>排序数组给一个target，找到一对相加等于target的。</p>
<ol>
<li>依次遍历，对于第一个数x，在后面找target-x；</li>
<li>利用hashmap，对于数x，在map里找是否存在target-x；</li>
<li>双指针法：初始一个指针在第一个数字，第二个指针在末尾的数字。两个数字相加，如果和大于target，则高指针下移。如果和小于target。则低指针上移。直到两个指针相遇。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">bool FindNumbersWithSum(int data[], int length, int sum, </span><br><span class="line">                        int* num1, int* num2)</span><br><span class="line">&#123;</span><br><span class="line">    bool found = false;</span><br><span class="line">    if(length &lt; 1 || num1 == nullptr || num2 == nullptr)</span><br><span class="line">        return found;</span><br><span class="line"></span><br><span class="line">    int ahead = length - 1;</span><br><span class="line">    int behind = 0;</span><br><span class="line"></span><br><span class="line">    while(ahead &gt; behind)</span><br><span class="line">    &#123;</span><br><span class="line">        long long curSum = data[ahead] + data[behind];</span><br><span class="line"></span><br><span class="line">        if(curSum == sum)</span><br><span class="line">        &#123;</span><br><span class="line">            *num1 = data[behind];</span><br><span class="line">            *num2 = data[ahead];</span><br><span class="line">            found = true;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(curSum &gt; sum)</span><br><span class="line">            ahead --;</span><br><span class="line">        else</span><br><span class="line">            behind ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果要求打印出所有对，则低+高&lt;=target时，低右移动，且跳过与之前一样的。</p>
<p>threesum：调用之前twosum的接口，把数组分为两部分，一个是第一个数字x，一个剩余部分，在剩余部分找target-x的twosum。之后右移动第一个数字，且跳过所有相同的，继续分割数组，在剩余数组内找twosum</p>
<p>题目2：输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）。例如输入15，由于1+2+3+4+5=4+5+6=7+8=15，所以结果打印出3个连续序列1～5、4～6和7～8。</p>
<p>设置small和big两个值，那么small到big就可以表示一个连续数组。初始small=1，big=2，如果small+到big&lt;target，则big+1；如果small+到big&gt;target，则small+1.一直到small到target/2为止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">void PrintContinuousSequence(int small, int big);</span><br><span class="line"></span><br><span class="line">void FindContinuousSequence(int sum)</span><br><span class="line">&#123;</span><br><span class="line">    if(sum &lt; 3)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    int small = 1; </span><br><span class="line">    int big = 2;</span><br><span class="line">    int middle = (1 + sum) / 2;</span><br><span class="line">    int curSum = small + big;</span><br><span class="line"></span><br><span class="line">    while(small &lt; middle)</span><br><span class="line">    &#123;</span><br><span class="line">        if(curSum == sum)</span><br><span class="line">            PrintContinuousSequence(small, big);</span><br><span class="line"></span><br><span class="line">        while(curSum &gt; sum &amp;&amp; small &lt; middle)</span><br><span class="line">        &#123;</span><br><span class="line">            curSum -= small;</span><br><span class="line">            small ++;</span><br><span class="line"></span><br><span class="line">            if(curSum == sum)</span><br><span class="line">                PrintContinuousSequence(small, big);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        big ++;</span><br><span class="line">        curSum += big;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PrintContinuousSequence(int small, int big)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = small; i &lt;= big; ++ i)</span><br><span class="line">        printf(&quot;%d &quot;, i);</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="58-翻转单词顺序"><a href="#58-翻转单词顺序" class="headerlink" title="58.翻转单词顺序"></a>58.翻转单词顺序</h3><p>题目：输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<p>分两步：第一步翻转所有字符，第二步翻转每个单词的字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &quot;..\Utilities\StringUtil.h&quot;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">char* ReverseSentence(char *pData)</span><br><span class="line">&#123;</span><br><span class="line">    if(pData == nullptr)</span><br><span class="line">        return nullptr;</span><br><span class="line"></span><br><span class="line">    char *pBegin = pData;</span><br><span class="line"></span><br><span class="line">    char *pEnd = pData;</span><br><span class="line">    while(*pEnd != &apos;\0&apos;)</span><br><span class="line">        pEnd ++;</span><br><span class="line">    pEnd--;</span><br><span class="line"></span><br><span class="line">    // 翻转整个句子</span><br><span class="line">    Reverse(pBegin, pEnd);</span><br><span class="line"></span><br><span class="line">    // 翻转句子中的每个单词</span><br><span class="line">    pBegin = pEnd = pData;</span><br><span class="line">    while(*pBegin != &apos;\0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*pBegin == &apos; &apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            pBegin ++;</span><br><span class="line">            pEnd ++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(*pEnd == &apos; &apos; || *pEnd == &apos;\0&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            Reverse(pBegin, --pEnd);</span><br><span class="line">            pBegin = ++pEnd;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            pEnd ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>题目：字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如输入字符串”abcdefg”和数字2，该函数将返回左旋转2位得到的结果”cdefgab”。</p>
<p>分两步：先翻转各自单词ab和cdefg，再翻转全部。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &quot;..\Utilities\StringUtil.h&quot;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">char* LeftRotateString(char* pStr, int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(pStr != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        int nLength = static_cast&lt;int&gt;(strlen(pStr));</span><br><span class="line">        if(nLength &gt; 0 &amp;&amp; n &gt; 0 &amp;&amp; n &lt; nLength)</span><br><span class="line">        &#123;</span><br><span class="line">            char* pFirstStart = pStr;</span><br><span class="line">            char* pFirstEnd = pStr + n - 1;</span><br><span class="line">            char* pSecondStart = pStr + n;</span><br><span class="line">            char* pSecondEnd = pStr + nLength - 1;</span><br><span class="line"></span><br><span class="line">            // 翻转字符串的前面n个字符</span><br><span class="line">            Reverse(pFirstStart, pFirstEnd);</span><br><span class="line">            // 翻转字符串的后面部分</span><br><span class="line">            Reverse(pSecondStart, pSecondEnd);</span><br><span class="line">            // 翻转整个字符串</span><br><span class="line">            Reverse(pFirstStart, pSecondEnd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="60-n个骰子的点数"><a href="#60-n个骰子的点数" class="headerlink" title="60.n个骰子的点数"></a>60.n个骰子的点数</h3><p>题目：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>
<p>n个骰子的点数，可以先把骰分成两堆，第一堆只有一个，第二堆n-1个，单独那一个有可能出现1-6的点数。我们需要计算1-6每一个点数和剩下的n-1个骰子计算点数和。接下来继续把剩下的n-1个骰子分成两部分，一堆只有一个，另一堆n-2个，把上一轮的点数和这一轮相加，再计算<br>n-2个的情况，直到还是最后一个。这就是一个递归的思路。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">int g_maxValue = 6;</span><br><span class="line"> </span><br><span class="line">// ====================方法一====================</span><br><span class="line">void Probability(int number, int* pProbabilities);</span><br><span class="line">void Probability(int original, int current, int sum, int* pProbabilities);</span><br><span class="line"></span><br><span class="line">void PrintProbability_Solution1(int number)</span><br><span class="line">&#123;</span><br><span class="line">    if(number &lt; 1)</span><br><span class="line">        return;</span><br><span class="line"> </span><br><span class="line">    int maxSum = number * g_maxValue;</span><br><span class="line">    int* pProbabilities = new int[maxSum - number + 1];</span><br><span class="line">    for(int i = number; i &lt;= maxSum; ++i)</span><br><span class="line">        pProbabilities[i - number] = 0;</span><br><span class="line"> </span><br><span class="line">    Probability(number, pProbabilities);</span><br><span class="line"> </span><br><span class="line">    int total = pow((double)g_maxValue, number);</span><br><span class="line">    for(int i = number; i &lt;= maxSum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        double ratio = (double)pProbabilities[i - number] / total;</span><br><span class="line">        printf(&quot;%d: %e\n&quot;, i, ratio);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    delete[] pProbabilities;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Probability(int number, int* pProbabilities)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 1; i &lt;= g_maxValue; ++i)</span><br><span class="line">        Probability(number, number, i, pProbabilities);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Probability(int original, int current, int sum, </span><br><span class="line">                 int* pProbabilities)</span><br><span class="line">&#123;</span><br><span class="line">    if(current == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        pProbabilities[sum - original]++;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = 1; i &lt;= g_maxValue; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            Probability(original, current - 1, i + sum, pProbabilities);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="62-圆圈中最后剩下的数字"><a href="#62-圆圈中最后剩下的数字" class="headerlink" title="62.圆圈中最后剩下的数字"></a>62.圆圈中最后剩下的数字</h3><p>题目：0, 1, …, n-1这n个数字排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>著名的约瑟夫环问题，其实就是一个环形链表，我们可以使用list来模拟实现，但是每当我们遍历到末尾数字时，就要自动回到链表开头。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// ====================方法1====================</span><br><span class="line">int LastRemaining_Solution1(unsigned int n, unsigned int m)</span><br><span class="line">&#123;</span><br><span class="line">    if(n &lt; 1 || m &lt; 1)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    unsigned int i = 0;</span><br><span class="line"></span><br><span class="line">    list&lt;int&gt; numbers;</span><br><span class="line">    for(i = 0; i &lt; n; ++ i)</span><br><span class="line">        numbers.push_back(i);</span><br><span class="line"></span><br><span class="line">    list&lt;int&gt;::iterator current = numbers.begin();</span><br><span class="line">    while(numbers.size() &gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = 1; i &lt; m; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            current ++;</span><br><span class="line">            if(current == numbers.end())</span><br><span class="line">                current = numbers.begin();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list&lt;int&gt;::iterator next = ++ current;</span><br><span class="line">        if(next == numbers.end())</span><br><span class="line">            next = numbers.begin();</span><br><span class="line"></span><br><span class="line">        -- current;</span><br><span class="line">        numbers.erase(current);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return *(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63.股票的最大利润"></a>63.股票的最大利润</h3><p>题目：假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖交易该股票可能获得的利润是多少？例如一只股票在某些时间节点的价格为{9, 11, 8, 5, 7, 12, 16, 14}。如果我们能在价格为5的时候买入并在价格为16时卖出，则能收获最大的利润11。</p>
<p>我们可以定义一个数组和输入数组一样大小，每个位置i表示，以当前价个卖出时获得的最大利润。这个数组计算玩后，最大值就是我们要的最大利润。计算位置i卖出的最大利润，只需要记得前i-1个值得最小值即可。所以再定义一个记录前i-1个数字最小值的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">int MaxDiff(const int* numbers, unsigned length)</span><br><span class="line">&#123;</span><br><span class="line">    if(numbers == nullptr &amp;&amp; length &lt; 2)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int min = numbers[0];</span><br><span class="line">    int maxDiff = numbers[1] - min;</span><br><span class="line"></span><br><span class="line">    for(int i = 2; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(numbers[i - 1] &lt; min)</span><br><span class="line">            min = numbers[i - 1];</span><br><span class="line"></span><br><span class="line">        int currentDiff = numbers[i] - min;</span><br><span class="line">        if(currentDiff &gt; maxDiff)</span><br><span class="line">            maxDiff = currentDiff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return maxDiff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="其它-from-zuochengyun-live"><a href="#其它-from-zuochengyun-live" class="headerlink" title="其它(from zuochengyun live)"></a>其它(from zuochengyun live)</h2><h3 id="1-两个有序数组A和B，找到最长的公共部分。"><a href="#1-两个有序数组A和B，找到最长的公共部分。" class="headerlink" title="1. 两个有序数组A和B，找到最长的公共部分。"></a>1. 两个有序数组A和B，找到最长的公共部分。</h3><p>思路1：双重循环，遍历A遍历B，时间复杂度O(N×M)<br>思路2：对于A中每一个数字，去B中二分找。O(N×logM)<br>思路3：同时设立两个开始指针，la，lb。谁小谁动。两个相等时一起动。O(N+M)<br>注意：不能说O(N+M)优于O(N×logM)，看数据量。</p>
<h3 id="2-调换左右两部分-12345-67-—–-67-12345"><a href="#2-调换左右两部分-12345-67-—–-67-12345" class="headerlink" title="2.调换左右两部分 12345 67 —– 67 12345"></a>2.调换左右两部分 12345 67 —– 67 12345</h3><p>左右两部分依次单独逆序，12345—–54321 67—-76，得到54321  76，再把整体逆序： 67  12345.<br>注意：逆序本身没有空间开销，高低两个指针互换即可。</p>
<h3 id="3-关于sort-函数"><a href="#3-关于sort-函数" class="headerlink" title="3.关于sort()函数"></a>3.关于sort()函数</h3><p>sort(A), size(A)=N;</p>
<ol>
<li>如果n&lt;60，直接插入排序。O(N^2),N较小时，平方也不大。但是常数空间O(1) (基于比较交换的排序都是)。</li>
<li>n&gt;60;则选择快速排序和归并排序。当比较类型为基本类型时，选择快排。如果是类类型时，选择归并排序。</li>
</ol>
<h3 id="4-一个无序数组输出其排序后相邻差值最大的差值。O-N"><a href="#4-一个无序数组输出其排序后相邻差值最大的差值。O-N" class="headerlink" title="4.一个无序数组输出其排序后相邻差值最大的差值。O(N)"></a>4.一个无序数组输出其排序后相邻差值最大的差值。O(N)</h3><ol>
<li>0(N)的复杂度就要求我们不能进行普通排序，我们可以进行桶排序。<br>2.遍历一次数组，得到最大值和最小值[x,y]，以及数组长度N，则设立N+1个桶(等分[x,y])，把N个数塞入N+1个桶，则至少有一个空桶。该空桶前一个桶的最大值和后一个桶的最小值差值大于一个桶的范围。所以我们找最大差值时不需要考虑桶内的情况。</li>
</ol>
<h3 id="5-用数组实现队列"><a href="#5-用数组实现队列" class="headerlink" title="5.用数组实现队列"></a>5.用数组实现队列</h3><p>1.用两个指针，end表示从那个位置入队，start表示从哪个位置出队。end和start初始都在数组开头，两者无关。但是设立size值，表示当前队列长度。当size为N时，end回到数组开头，不可以入队。size只要不为0，start就可以动。</p>
<h3 id="6-之字型打印矩阵"><a href="#6-之字型打印矩阵" class="headerlink" title="6.之字型打印矩阵"></a>6.之字型打印矩阵</h3><p>最左上角位置l两个指针(r1,c1) (r2,c2)，前者往右走，走到不能走往下走。后者往下走，走到不能走往右走。两个指针每移动一次就会形成一条对角线。打印该对角线。</p>
<h3 id="7-输出N个有序数组整体最大的TOP-K"><a href="#7-输出N个有序数组整体最大的TOP-K" class="headerlink" title="7. 输出N个有序数组整体最大的TOP K"></a>7. 输出N个有序数组整体最大的TOP K</h3><p>建立大小为N的大顶堆，第一步，首先把N个数组最后最大的数插入堆。然后输出该堆顶，并且把堆顶元素所在的数组下一个位置的元素插入堆中，重新建堆。然后再输出堆顶。经过k次，就可以得到最大的k个数。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/oj/" rel="tag"># oj</a>
          
            <a href="/tags/面试/" rel="tag"># 面试</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/16/Practice-for-coding-online-test/" rel="next" title="Practice for coding online test">
                <i class="fa fa-chevron-left"></i> Practice for coding online test
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/16/Leetcode-二叉树解题报告/" rel="prev" title="Leetcode 二叉树解题报告">
                Leetcode 二叉树解题报告 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/xw.jpg" alt="Poemlin">
            
              <p class="site-author-name" itemprop="name">Poemlin</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">39</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-找出数组中重复的数字"><span class="nav-number">1.</span> <span class="nav-text">1. 找出数组中重复的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-不修改数组找出重复的数字"><span class="nav-number">2.</span> <span class="nav-text">2. 不修改数组找出重复的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-有序二维数组中找是否存在某个整数"><span class="nav-number">3.</span> <span class="nav-text">3. 有序二维数组中找是否存在某个整数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-替换空格"><span class="nav-number">4.</span> <span class="nav-text">4 替换空格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-从尾到头打印链表"><span class="nav-number">5.</span> <span class="nav-text">5. 从尾到头打印链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-先序中序重建二叉树"><span class="nav-number">6.</span> <span class="nav-text">6.先序中序重建二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-二叉树的下一个结点"><span class="nav-number">7.</span> <span class="nav-text">7.二叉树的下一个结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-用栈实现队列。"><span class="nav-number">8.</span> <span class="nav-text">8.用栈实现队列。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-斐波那契数列"><span class="nav-number">9.</span> <span class="nav-text">9.斐波那契数列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-在旋转数组中查找某个数字"><span class="nav-number">10.</span> <span class="nav-text">10.在旋转数组中查找某个数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-矩阵中的路径"><span class="nav-number">11.</span> <span class="nav-text">11.矩阵中的路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-机器人的运动范围"><span class="nav-number">12.</span> <span class="nav-text">12.机器人的运动范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-剪绳子"><span class="nav-number">13.</span> <span class="nav-text">13.剪绳子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-二进制中1的个数"><span class="nav-number">14.</span> <span class="nav-text">14.二进制中1的个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-数值的k次方"><span class="nav-number">15.</span> <span class="nav-text">15.数值的k次方</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-打印1到最大的n位数"><span class="nav-number">16.</span> <span class="nav-text">16.打印1到最大的n位数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-在O-1-时间删除链表结点"><span class="nav-number">17.</span> <span class="nav-text">17 在O(1)时间删除链表结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-调整数组顺序使奇数位于偶数前面"><span class="nav-number">18.</span> <span class="nav-text">18. 调整数组顺序使奇数位于偶数前面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-链表中倒数第k个结点"><span class="nav-number">19.</span> <span class="nav-text">22.链表中倒数第k个结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-链表中环的入口结点"><span class="nav-number">20.</span> <span class="nav-text">23.链表中环的入口结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-反转链表"><span class="nav-number">21.</span> <span class="nav-text">24.反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-合并两个排序的链表"><span class="nav-number">22.</span> <span class="nav-text">25.合并两个排序的链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-树的子结构"><span class="nav-number">23.</span> <span class="nav-text">26.树的子结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-二叉树的镜像"><span class="nav-number">24.</span> <span class="nav-text">27.二叉树的镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-对称的二叉树"><span class="nav-number">25.</span> <span class="nav-text">28.对称的二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29-顺时针打印矩阵"><span class="nav-number">26.</span> <span class="nav-text">29.顺时针打印矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30-包含min函数的栈"><span class="nav-number">27.</span> <span class="nav-text">30.包含min函数的栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-不分行从上往下打印二叉树"><span class="nav-number">28.</span> <span class="nav-text">32 不分行从上往下打印二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-二叉搜索树的后序遍历序列"><span class="nav-number">29.</span> <span class="nav-text">33.二叉搜索树的后序遍历序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34-二叉树中和为某一值的路径"><span class="nav-number">30.</span> <span class="nav-text">34 二叉树中和为某一值的路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36-二叉搜索树与双向链表"><span class="nav-number">31.</span> <span class="nav-text">36.二叉搜索树与双向链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38-字符串的全排列"><span class="nav-number">32.</span> <span class="nav-text">38 字符串的全排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39-数组中出现次数超过一半的数字"><span class="nav-number">33.</span> <span class="nav-text">39.数组中出现次数超过一半的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-最小的k个数"><span class="nav-number">34.</span> <span class="nav-text">40.最小的k个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-连续子数组的最大和"><span class="nav-number">35.</span> <span class="nav-text">42.连续子数组的最大和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#50-字符串中第一个只出现一次的字符"><span class="nav-number">36.</span> <span class="nav-text">50.字符串中第一个只出现一次的字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#52-两个链表的第一个公共结点"><span class="nav-number">37.</span> <span class="nav-text">52.两个链表的第一个公共结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53-在排序数组中查找数字"><span class="nav-number">38.</span> <span class="nav-text">53.在排序数组中查找数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#54-二叉搜索树的第k个结点"><span class="nav-number">39.</span> <span class="nav-text">54.二叉搜索树的第k个结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#55-二叉树的深度"><span class="nav-number">40.</span> <span class="nav-text">55.二叉树的深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#57-和为s的两个数字"><span class="nav-number">41.</span> <span class="nav-text">57.和为s的两个数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#58-翻转单词顺序"><span class="nav-number">42.</span> <span class="nav-text">58.翻转单词顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#60-n个骰子的点数"><span class="nav-number">43.</span> <span class="nav-text">60.n个骰子的点数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#62-圆圈中最后剩下的数字"><span class="nav-number">44.</span> <span class="nav-text">62.圆圈中最后剩下的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63-股票的最大利润"><span class="nav-number">45.</span> <span class="nav-text">63.股票的最大利润</span></a></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#其它-from-zuochengyun-live"><span class="nav-number"></span> <span class="nav-text">其它(from zuochengyun live)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-两个有序数组A和B，找到最长的公共部分。"><span class="nav-number">1.</span> <span class="nav-text">1. 两个有序数组A和B，找到最长的公共部分。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-调换左右两部分-12345-67-—–-67-12345"><span class="nav-number">2.</span> <span class="nav-text">2.调换左右两部分 12345 67 —– 67 12345</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-关于sort-函数"><span class="nav-number">3.</span> <span class="nav-text">3.关于sort()函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-一个无序数组输出其排序后相邻差值最大的差值。O-N"><span class="nav-number">4.</span> <span class="nav-text">4.一个无序数组输出其排序后相邻差值最大的差值。O(N)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-用数组实现队列"><span class="nav-number">5.</span> <span class="nav-text">5.用数组实现队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-之字型打印矩阵"><span class="nav-number">6.</span> <span class="nav-text">6.之字型打印矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-输出N个有序数组整体最大的TOP-K"><span class="nav-number">7.</span> <span class="nav-text">7. 输出N个有序数组整体最大的TOP K</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Poemlin</span>

  
</div>
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_pv"></span>
</span>
</div>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
